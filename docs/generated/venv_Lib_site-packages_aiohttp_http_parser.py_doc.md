# aiohttp.http_parser – HTTP Message Parsing Core  

*File: `venv/Lib/site-packages/aiohttp/http_parser.py`*  

---

## 1. Module Purpose  

| What | Why |
|------|-----|
| **Parse raw HTTP request/response bytes** into structured objects (`RawRequestMessage`, `RawResponseMessage`). | asyncio‑based servers and clients need a non‑blocking, spec‑compliant way to turn network data into logical HTTP messages. |
| **Interpret and validate HTTP headers** (field names, values, continuation lines, duplicate‑singleton checks, transport‑related logic). | Guarantees correct behavior according to RFC 9110/9112, protects against malformed or malicious payloads. |
| **Handle message bodies** – fixed `Content‑Length`, chunked transfer‑encoding, “read‑until‑EOF”, optional automatic decompression (gzip/deflate/br/zstd). | Centralises payload parsing so higher‑level code (e.g., `aiohttp.web.Request`, `ClientResponse`) receives a ready‑to‑read `StreamReader`. |
| **Expose two concrete parsers** – `HttpRequestParser` for inbound server requests, `HttpResponseParser` for inbound client responses – both inheriting from an abstract `HttpParser`. | Enables reuse of the same low‑level machinery while allowing request‑specific vs. response‑specific nuances (e.g., lax mode for responses). |
| **Provide a pure‑Python fallback** (`*_Py` symbols) that is automatically replaced by a Cython implementation when available. | Keeps the public API stable while allowing a high‑performance compiled version. |

---

## 2. Key Components  

### 2.1 Data Containers  

| Symbol | Description | Fields |
|--------|-------------|--------|
| `RawRequestMessage` | NamedTuple representing a fully parsed HTTP request line plus headers. | `method: str`, `path: str`, `version: HttpVersion`, `headers: CIMultiDictProxy[str]`, `raw_headers: RawHeaders`, `should_close: bool`, `compression: Optional[str]`, `upgrade: bool`, `chunked: bool`, `url: URL` |
| `RawResponseMessage` | NamedTuple representing a parsed HTTP response status line plus headers. | `version: HttpVersion`, `code: int`, `reason: str`, `headers: CIMultiDictProxy[str]`, `raw_headers: RawHeaders`, `should_close: bool`, `compression: Optional[str]`, `upgrade: bool`, `chunked: bool` |

These containers are returned by the concrete parsers and later consumed by higher‑level request/response objects.

---

### 2.2 Enumerations  

| Enum | Members | Meaning |
|------|---------|---------|
| `ParseState` | `PARSE_NONE`, `PARSE_LENGTH`, `PARSE_CHUNKED`, `PARSE_UNTIL_EOF` | High‑level body parsing mode. |
| `ChunkState` | `PARSE_CHUNKED_SIZE`, `PARSE_CHUNKED_CHUNK`, `PARSE_CHUNKED_CHUNK_EOF`, `PARSE_MAYBE_TRAILERS`, `PARSE_TRAILERS` | Internal state machine for chunked transfer‑encoding. |

---

### 2.3 `HeadersParser`  

**Purpose** – Low‑level, RFC‑5322 header parsing with optional “lax” continuation‑line handling.  

**Constructor**  

```python
HeadersParser(
    max_line_size: int = 8190,
    max_headers: int = 32768,
    max_field_size: int = 8190,
    lax: bool = False,
)
```

* Validates header name tokens (`TOKENRE`) and length limits.  
* Supports deprecated line folding when `lax=True`.  

**Public method**  

```python
parse_headers(lines: List[bytes]) -> Tuple[CIMultiDictProxy[str], RawHeaders]
```

* Input: list of raw header lines (already split on CRLF).  
* Output: an immutable multi‑dict of decoded header names/values and a tuple of the original `(name_bytes, value_bytes)` pairs.  
* Raises `InvalidHeader`, `LineTooLong` on malformed data.

---

### 2.4 Abstract Base – `HttpParser[_MsgT]`  

*Generic* over the message type (`RawRequestMessage` or `RawResponseMessage`).  

| Attribute | Meaning |
|-----------|---------|
| `protocol` | Optional `BaseProtocol` that provides low‑level transport hooks. |
| `loop` | Optional event loop reference. |
| `max_line_size`, `max_headers`, `max_field_size` | Limits inherited from `HeadersParser`. |
| `_lines` | Accumulated header lines until a blank line is seen. |
| `_tail` | Partial data waiting for the next feed. |
| `_upgraded` | `True` when an “Upgrade” (e.g., websocket) has been accepted. |
| `_payload_parser` | Instance of `HttpPayloadParser` handling the body. |
| `_auto_decompress` | Enables automatic decompression of the body if required. |
| `_headers_parser` | Instance of `HeadersParser`. |

**Abstract methods**  

* `parse_message(self, lines: List[bytes]) -> _MsgT` – concrete parser turns header lines into a message tuple.  
* `_is_chunked_te(self, te: str) -> bool` – determines whether a `Transfer‑Encoding` header signals chunked encoding.

**Core public API**  

* `feed_data(data: bytes, ...) -> Tuple[List[Tuple[_MsgT, StreamReader]], bool, bytes]`  
  * Incrementally consumes `data`.  
  * Returns a list of `(message, payload_stream)` pairs that are fully parsed, a flag indicating whether the connection is upgraded, and any leftover bytes.  
* `feed_eof() -> Optional[_MsgT]` – called when the transport signals EOF; tries to parse any trailing partial message.  
* `parse_headers(lines: List[bytes]) -> Tuple[CIMultiDictProxy[str], RawHeaders, Optional[bool], Optional[str], bool, bool]` – performs generic header validation, returns flags for `close`, `compression`, `upgrade`, `chunked`.  
* `set_upgraded(val: bool)` – manually flips the upgrade flag.

---

### 2.5 `HttpRequestParser` (inherits `HttpParser[RawRequestMessage]`)  

*Parses the request line* (`METHOD SP request-target SP HTTP-version CRLF`) and then delegates header parsing to the base class.  

**Key behaviours**  

* Validates method token via `TOKENRE`.  
* Supports three request‑target forms: `authority-form` for CONNECT, `origin-form` (`/path?...`), `asterisk-form` for OPTIONS, and absolute‑form (proxy).  
* Constructs a `yarl.URL` using `URL.build` to match Cython parser behaviour.  
* Determines `should_close` based on HTTP version and explicit `Connection` header.  

**Chunked detection** – uses `_is_chunked_te` which checks that the *last* value in a comma‑separated list equals `"chunked"`; otherwise raises `BadHttpMessage`.

---

### 2.6 `HttpResponseParser` (inherits `HttpParser[RawResponseMessage]`)  

*Parses the response status line* (`HTTP-version SP status-code SP reason-phrase CRLF`).  

**Specialities**  

* **Lax mode** – enabled when `DEBUG` is false; permits `\n` line endings instead of `\r\n`.  
* Determines `should_close` based on HTTP version, status code classes, and presence of `Content‑Length`/`Transfer‑Encoding`.  
* Chunked detection identical to request parser (`_is_chunked_te`).  

**Overrides**  

* `feed_data` – selects appropriate line separator (`\r\n` normally, `\n` in lax mode).  

---

### 2.7 `HttpPayloadParser`  

Handles the body after headers have been processed.  

**Constructor arguments**  

* `payload: StreamReader` – destination stream that receives decompressed data.  
* `length: Optional[int]` – expected body size (from `Content‑Length`).  
* `chunked: bool` – whether chunked transfer‑encoding is used.  
* `compression: Optional[str]` – value of `Content‑Encoding` (e.g., `"gzip"`).  
* `code`, `method`, `response_with_body`, `auto_decompress`, `lax`, `headers_parser` – additional context.  

**Behaviour**  

| Mode | Decision logic |
|------|----------------|
| `PARSE_NONE` | No body expected (e.g., HEAD, 204). Immediately marks `done=True`. |
| `PARSE_LENGTH` | Reads exactly `length` bytes, then signals EOF. |
| `PARSE_CHUNKED` | Drives the chunk‑state machine (`ChunkState`). Handles optional extensions, trailer headers, and validates hex size. |
| `PARSE_UNTIL_EOF` | Streams everything until EOF (used when `read_until_eof=True`). |

*If `auto_decompress` is *True* and a known encoding is present, the payload is wrapped in a `DeflateBuffer` which handles on‑the‑fly decompression.*

**Public API**  

* `feed_data(chunk: bytes, SEP: _SEP = b"\r\n", CHUNK_EXT: bytes = b";") -> Tuple[bool, bytes]` – consumes a chunk of raw data, returns `(eof, leftover)`.  
* `feed_eof()` – finalises the payload according to the current state, raising errors for premature EOF.

---

### 2.8 `DeflateBuffer`  

Wraps a `StreamReader` to automatically decompress supported encodings (`br`, `gzip`, `deflate`, `zstd`).  

**Key points**  

* Instantiates the appropriate decompressor (`BrotliDecompressor`, `ZLibDecompressor`, `ZSTDDecompressor`).  
* Handles the special case where a `deflate` stream is missing the zlib header (RFC 1950) by switching to a “header‑less” decoder on the first chunk.  
* `feed_data` – decompresses a chunk, forwards the result to the underlying `StreamReader`.  
* `feed_eof` – flushes the decompressor, checks for premature EOF for `deflate`.  
* Provides `begin_http_chunk_receiving` / `end_http_chunk_receiving` pass‑through for chunked bodies.

---

### 2.9 Compatibility shims  

At the bottom of the file the module tries to import a compiled version (`_http_parser`). When successful it re‑exports the Cython classes as `HttpRequestParserC`, `HttpResponseParserC`, etc. If the import fails (e.g., pure‑Python environment) the pure‑Python implementations defined above are used.  

```python
HttpRequestParserPy = HttpRequestParser
HttpResponseParserPy = HttpResponseParser
...
```

---

## 3. Dependencies & Relationships  

### 3.1 Direct Imports  

| Module | Imported Symbol(s) | Reason |
|--------|-------------------|--------|
| `abc` | `ABC` (via `abc.ABC`) | Abstract base class for `HttpParser`. |
| `asyncio` | `AbstractEventLoop` | Event‑loop reference for async I/O. |
| `re`, `string` | regex utilities, `ASCIISET` | Header validation, token detection. |
| `contextlib` | `suppress` | Quietly ignore exceptions in `feed_eof`. |
| `enum` | `IntEnum` | Define `ParseState`, `ChunkState`. |
| `typing` | many (e.g., `Tuple`, `List`, `Optional`) | Type hinting for public API. |
| `multidict` | `CIMultiDict`, `CIMultiDictProxy`, `istr` | Case‑insensitive multi‑dictionary for HTTP headers. |
| `yarl` | `URL` | URL parsing/normalisation for request targets. |
| `.hdrs` | constant header names (e.g., `CONTENT_LENGTH`) | Centralised header name definitions. |
| `.base_protocol` | `BaseProtocol` | Transport abstraction used by `StreamReader`. |
| `.compression_utils` | Decompressor classes + feature flags | Automatic content‑encoding handling. |
| `.helpers` | many helper constants & utilities (`EMPTY_BODY_METHODS`, `set_exception`, etc.) | Shared utilities across aiohttp. |
| `.http_exceptions` | exception classes (`BadHttpMessage`, `InvalidHeader`, …) | Domain‑specific error reporting. |
| `.http_writer` | `HttpVersion`, `HttpVersion10` | Version representation. |
| `.streams` | `EMPTY_PAYLOAD`, `StreamReader` | Body streaming abstraction. |
| `.typedefs` | `RawHeaders` | Alias for raw header tuples. |
| (optional) `._http_parser` | Cython implementation of parsers | Performance‑optimized fallback. |

### 3.2 Interaction with Other aiohttp Components  

| Component | How `http_parser` uses it | Who uses `http_parser` |
|-----------|--------------------------|------------------------|
| `aiohttp.StreamReader` (`streams.py`) | Receives parsed body data, supports chunk callbacks, EOF handling. | `aiohttp.web.Request`, `aiohttp.client_reqrep.ClientResponse` |
| `BaseProtocol` (`base_protocol.py`) | Provides low‑level transport for `StreamReader`. | `aiohttp.web.Server`, `aiohttp.client_reqrep.ClientConnection` |
| Header constants (`hdrs.py`) | Normalises lookup of standard header names. | All parsers & higher‑level request/response objects. |
| `HttpVersion` (`http_writer.py`) | Represents HTTP/1.0, 1.1, etc. | Returned in `Raw*Message`, later used by protocol logic. |
| `compression_utils` | Supplies stream decompressor classes. | `DeflateBuffer` for auto‑decompression. |
| `helpers` | Shared constants (`EMPTY_BODY_METHODS`, `DEBUG`) and utility `set_exception`. | Used throughout for validation and error handling. |
| `yarl.URL` | Normalises request‑target strings to URL objects. | `HttpRequestParser` builds `url` field. |
| Cython parser (`_http_parser`) | If present, replaces the Python implementations for speed. | The rest of aiohttp imports `HttpRequestParser`/`HttpResponseParser` from this module; they may be the Cython versions transparently. |

### 3.3 Architectural Placement  

* **Layer**: Low‑level I/O/parsing (just above the transport, below higher‑level request/response objects).  
* **Responsibility**: Transform raw byte streams into structured messages **without** performing application logic.  
* **Consumer**: Server (`aiohttp.web.Server`) & client (`aiohttp.client_reqrep`) implementations that instantiate a parser per connection, feed data as it arrives, and hand the resulting `StreamReader` to request/response objects.  

---

## 4. Workflow Description  

1. **Parser Instantiation**  
   * Server side: `HttpRequestParser(protocol, loop, ...)`  
   * Client side: `HttpResponseParser(protocol, loop, ...)` (lax mode may be active).  

2. **Data Arrival** – Transport calls `parser.feed_data(chunk)`.  

3. **Header Accumulation**  
   * If no payload parser is active and connection not upgraded, the method looks for the separator (`SEP`, default `\r\n`).  
   * Lines are appended to `self._lines` until an empty line (`b""`) signals end of headers.  

4. **Message Construction** (`parse_message`)  
   * The concrete parser (`HttpRequestParser` or `HttpResponseParser`) parses the first line, builds a `Raw*Message`.  
   * Calls `self.parse_headers` to validate and extract flags (`should_close`, `compression`, `upgrade`, `chunked`).  

5. **Body Determination**  
   * Based on method, status code, `Content‑Length`, and `Transfer‑Encoding`.  
   * If a body is expected: create a `StreamReader` and a `HttpPayloadParser`.  
   * If the `Upgrade` header is present and supported → set `_upgraded=True`.  

6. **Payload Feeding**  
   * Subsequent calls to `feed_data` are routed to the `HttpPayloadParser`.  
   * Depending on the parsing state:  
     * **Length mode** – consume exact number of bytes.  
     * **Chunked mode** – run through chunk‐state machine, handling extensions and optional trailer headers.  
     * **Until‑EOF** – stream everything.  

7. **Decompression (optional)**  
   * If `auto_decompress=True` and a known `Content‑Encoding` is present, a `DeflateBuffer` wraps the `StreamReader`.  
   * The buffer decompresses each incoming chunk and forwards plain data downstream.  

8. **Completion**  
   * When the payload parser signals EOF (`True`), `self._payload_parser` is cleared, and the next message can be parsed from remaining data.  
   * `feed_eof` called on connection close: propagates EOF to any active payload parser or attempts to parse a trailing incomplete message.  

9. **Upgrade Path**  
   * When an Upgrade has been negotiated (`_upgraded=True`), the parser stops further HTTP parsing; the underlying protocol takes over (e.g., WebSocket).  

---

## 5. Usage Examples  

Below are minimal, **realistic** snippets that demonstrate the public API. They rely only on symbols defined in this module and on standard aiohttp objects.

### 5.1 Parsing a raw HTTP request (server side)

```python
from aiohttp.http_parser import HttpRequestParser, HttpRequestParserPy
from aiohttp.base_protocol import BaseProtocol
import asyncio

# Mock protocol – in the real server aiohttp creates a subclass.
class DummyProtocol(BaseProtocol):
    def __init__(self):
        self.transport = None   # not used in this example

protocol = DummyProtocol()
loop = asyncio.get_event_loop()

parser = HttpRequestParser(protocol=protocol, loop=loop)

# Simulate receiving data in two fragments.
data1 = b'GET /index.html HTTP/1.1\r\nHost: example.com\r\n'
data2 = b'Connection: close\r\n\r\nHello world'

messages, upgraded, leftover = parser.feed_data(data1)
# No complete message yet → messages == []
messages, upgraded, leftover = parser.feed_data(data2)

# `messages` now contains a single tuple:
# (RawRequestMessage, StreamReader)
raw_msg, payload = messages[0]

print(raw_msg.method)   # "GET"
print(raw_msg.path)     # "/index.html"
print(raw_msg.headers['host'])   # "example.com"

# Read the body (if any) from `payload` – here it contains b'Hello world'.
body = await payload.read()
print(body)   # b'Hello world'
```

### 5.2 Parsing a raw HTTP response (client side, lax mode)

```python
from aiohttp.http_parser import HttpResponseParser
parser = HttpResponseParser()

# A raw HTTP/1.0 response that ends with a single LF (lax mode)
data = b'HTTP/1.0 200 OK\nContent-Length: 5\n\nHello'

messages, upgraded, leftover = parser.feed_data(data)

raw_resp, payload = messages[0]
print(raw_resp.version)   # HttpVersion(1, 0)
print(raw_resp.code)      # 200
print(raw_resp.reason)    # "OK"
print(await payload.read())  # b'Hello'
```

### 5.3 Handling a chunked response with automatic decompression

```python
from aiohttp.http_parser import HttpResponseParser
parser = HttpResponseParser(auto_decompress=True)

# Simplified chunked + gzip payload (illustrative only)
data = (
    b'HTTP/1.1 200 OK\r\n'
    b'Transfer-Encoding: chunked\r\n'
    b'Content-Encoding: gzip\r\n\r\n'
    b'5\r\n' + b'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03' + b'\n'  # chunk size=5 (gzip header)
    b'0\r\n\r\n'
)
messages, _, _ = parser.feed_data(data)
msg, payload = messages[0]
print(msg.chunked)           # True
print(msg.compression)      # "gzip"

# The payload is already decompressed by DeflateBuffer.
plain_body = await payload.read()
print(plain_body)           # b'\n' (the original uncompressed data)
```

> **Note:** In real aiohttp usage parsing is done internally; developers usually work with higher‑level `Request`/`Response` objects rather than directly with parsers.

---

## 6. Notes for Developers  

| Topic | Details / Gotchas |
|-------|-------------------|
| **Lax parsing** | Only `HttpResponseParser` can operate in lax mode (`lax = not DEBUG`). It relaxes line‑ending rules (accepts `\n`) and permits whitespace in chunk size. Use with care – it may accept non‑compliant servers. |
| **Header continuation lines** | Supported **only** when the parser is constructed with `lax=True`. Modern HTTP forbids folding; most production code leaves this disabled. |
| **Maximum limits** | `max_line_size`, `max_headers`, `max_field_size` are enforced early. Raising `LineTooLong` protects against DoS attacks via huge headers. |
| **Duplicate singleton headers** | Detected by `parse_headers`; if a header that must appear at most once appears multiple times, a `BadHttpMessage` is raised. |
| **Upgrade handling** | After an upgrade is accepted (`_is_supported_upgrade`), the parser stops processing HTTP and hands control to the underlying protocol. The caller must reset or replace the parser accordingly. |
| **Chunked transfer** | The chunk parser is *strict* by default: must end each chunk with the exact separator (`\r\n` unless lax) and the size must be a valid hex string. Errors raise `TransferEncodingError`. |
| **Content‑Encoding support** | `DeflateBuffer` automatically selects the proper decompressor. If the required third‑party library (brotli or zstd) is missing, a `ContentEncodingError` is raised at the moment the payload is first processed. |
| **`StreamReader` interaction** | The parser only *feeds* data into a `StreamReader`. It never reads from it. Thus the `StreamReader` must be correctly attached to a transport (via `BaseProtocol`) for flow‑control, otherwise the buffer may grow unchecked. |
| **EOF handling** | `feed_eof` validates that the expected number of bytes have been received. Premature EOF raises `ContentLengthError` (fixed length) or `TransferEncodingError` (chunked). |
| **Cython fallback** | When the compiled `_http_parser` module is present, the symbols `HttpRequestParser`, `HttpResponseParser`, `RawRequestMessage`, `RawResponseMessage` are *replaced* by the fast Cython versions. The Python implementations (`*Py`) remain available for testing or environments where compilation is impossible. |
| **Testing** | Unit tests should cover: various request‑target forms, all status‑code branches, chunked + trailer parsing, malformed headers, edge cases (empty bodies, connection close, upgrade). |
| **Thread safety** | Parsers are **not** thread‑safe; they must be used only within a single asyncio event loop. |
| **Future extensions** | The current design isolates header parsing (`HeadersParser`) and body parsing (`HttpPayloadParser`). Adding support for newer transfer encodings (e.g., `chunked` extensions) should be done within `HttpPayloadParser` without changing the outer `HttpParser` logic. |

--- 

**End of documentation.**