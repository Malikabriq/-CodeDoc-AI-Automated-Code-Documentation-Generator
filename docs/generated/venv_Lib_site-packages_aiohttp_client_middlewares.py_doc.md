# ðŸ“„ aiohttp.client_middlewares â€“ Clientâ€‘Side Middleware Engine  

*File:* `venv\Lib\site-packages\aiohttp\client_middlewares.py`

---  

## 1. Module Purpose  

| Aspect | Description |
|--------|-------------|
| **Responsibility** | Supplies the plumbing that lets *aiohttp* users compose **clientâ€‘side middlewares** â€“ callâ€‘sites that can inspect, modify, or replace a `ClientRequest` before it is sent and/or a `ClientResponse` after it is received. |
| **Why it exists** | While aiohttpâ€™s server side already has a mature middleware system, the client side needs a lightweight, zeroâ€‘overhead way to chain userâ€‘provided callables around the core request handler (`ClientSession._request`). This module implements that chainâ€‘building logic without pulling in heavy wrappers or referenceâ€‘leaking caches. |

---

## 2. Key Components  

### 2.1 Type Aliases  

| Alias | Definition | Purpose |
|-------|------------|---------|
| `ClientHandlerType` | `Callable[[ClientRequest], Awaitable[ClientResponse]]` | The *final* coroutine that receives a `ClientRequest` and returns a `ClientResponse`. In practice this is the lowâ€‘level request implementation inside `aiohttp.ClientSession`. |
| `ClientMiddlewareType` | `Callable[[ClientRequest, ClientHandlerType], Awaitable[ClientResponse]]` | Signature that a middleware must implement. It receives the request and a *next* handler (which may be another middleware or the real request handler) and returns a response coroutine. |

These aliases are exported via `__all__` so downstream code can typeâ€‘hint against them.

---

### 2.2 `build_client_middlewares`  

```python
def build_client_middlewares(
    handler: ClientHandlerType,
    middlewares: Sequence[ClientMiddlewareType],
) -> ClientHandlerType:
    ...
```

#### What it does  
Creates a **single callable** (`ClientHandlerType`) that represents the original handler wrapped by the supplied middleware sequence. The resulting callable can be used wherever the original `handler` was expected.

#### Parameters  

| Name | Type | Description |
|------|------|-------------|
| `handler` | `ClientHandlerType` | The core request executor (e.g., `ClientSession._request`). |
| `middlewares` | `Sequence[ClientMiddlewareType]` | Ordered collection of middleware callables. The first element becomes the *outermost* wrapper. |

#### Return Value  

| Type | Meaning |
|------|---------|
| `ClientHandlerType` | A coroutine function that, when called with a `ClientRequest`, runs the middleware chain and eventually returns a `ClientResponse`. |

#### Internal Logic Overview  

1. **Fastâ€‘path for a single middleware** â€“ if there is exactly one middleware, a tiny wrapper (`single_middleware_handler`) is created that simply forwards the request to that middleware with the original handler as the *next* argument.  
2. **General case (â‰¥2 middlewares)** â€“  
   * Starts with `current_handler = handler`.  
   * Iterates the middleware list **in reverse** (`reversed(middlewares)`) so that the first middleware in the original order ends up as the outermost wrapper.  
   * For each middleware, a closure (`make_wrapper`) is built that captures the middleware (`mw`) and the *next* handler (`next_h`). The closure returns an async function `wrapped` that forwards the request to `mw(req, next_h)`.  
   * `current_handler` is updated to the newly created wrapper, effectively building a chain: `mwâ‚ â†’ mwâ‚‚ â†’ â€¦ â†’ handler`.  
3. **Result** â€“ after the loop, `current_handler` holds the fully composed handler, which is returned.

#### Public API Exposure  

- Exported via `__all__`:  
  ```python
  __all__ = ("ClientMiddlewareType", "ClientHandlerType", "build_client_middlewares")
  ```
- Intended to be invoked by `aiohttp` internals (e.g., when a `ClientSession` is constructed with a `request_class` that supplies middlewares) **or** directly by advanced users who want to compose their own client call stacks.

---

## 3. Dependencies & Relationships  

### Imports  

| Module | Symbol(s) | Reason |
|--------|-----------|--------|
| `collections.abc` | `Awaitable`, `Callable`, `Sequence` | Generic abstract base classes used for type annotations. |
| `.client_reqrep` | `ClientRequest`, `ClientResponse` | Concrete request/response classes that middlewares operate on. |

### Interâ€‘module Interactions  

| Direction | Component | How it interacts |
|-----------|-----------|-----------------|
| **Depends on** | `aiohttp.client_reqrep` | Uses `ClientRequest`/`ClientResponse` types for signatures. |
| **Used by** | `aiohttp.client` (e.g., `ClientSession`) | The session builds a request handler and passes it together with userâ€‘provided middlewares to `build_client_middlewares`. |
| **Potential consumers** | User code that builds custom client stacks | Users may import `ClientMiddlewareType` to typeâ€‘hint their own middleware functions, or call `build_client_middlewares` directly. |
| **Does not depend on** | Any networking code, eventâ€‘loop utilities, or higherâ€‘level aiohttp APIs. The module is deliberately lightweight. |

### Architectural Placement  

- **Layer**: *clientâ€‘side request pipeline* â€“ sits just before the lowâ€‘level HTTP transport layer.  
- **Role**: *composition* â€“ transforms a flat handler into a callable that respects the ordered middleware semantics.  
- **Relation to server side**: Mirrors the serverâ€‘side middleware builder (`aiohttp.web_middlewares`) but works with clientâ€‘specific request/response objects.

---

## 4. Workflow Description  

1. **Initial State** â€“ A `ClientHandlerType` (`handler`) is ready (e.g., `ClientSession._request`). A list of middleware callables (`middlewares`) is supplied by the user or by aiohttp configuration.  
2. **Invocation** â€“ `build_client_middlewares(handler, middlewares)` is called.  
3. **Fast Path** â€“ If exactly one middleware: a wrapper that calls `middleware(req, handler)` is returned.  
4. **Chain Construction (â‰¥2 middlewares)**  
   - Set `current_handler` to the original `handler`.  
   - Iterate over `middlewares` **backwards**. For each `middleware`:  
     a. Call `make_wrapper(middleware, current_handler)`.  
     b. Inside `make_wrapper`, define `wrapped(req)` â†’ `await middleware(req, next_h)`.  
     c. Replace `current_handler` with `wrapped`.  
   - After the loop, `current_handler` represents `mwâ‚(mwâ‚‚(...(handler)))`.  
5. **Return** â€“ The composed handler is given back to the caller.  
6. **Runtime** â€“ When the returned handler is awaited with a `ClientRequest`, the request flows through the outermost middleware, each inner middleware, finally the original handler, then back up the chain with the (potentially altered) `ClientResponse`.

---  

## 5. Usage Examples  

Below are **minimal, inferable snippets** that demonstrate how the API is intended to be used. No fictional code is introduced.

### 5.1 Defining a Simple Middleware  

```python
from aiohttp.client_middlewares import ClientMiddlewareType
from aiohttp.client_reqrep import ClientRequest, ClientResponse

async def add_header_middleware(
    request: ClientRequest,
    handler: Callable[[ClientRequest], Awaitable[ClientResponse]],
) -> ClientResponse:
    # Mutate the request â€“ add a custom header
    request.headers["X-My-Header"] = "value"
    # Forward to the next handler (could be another middleware or the real request)
    response = await handler(request)
    return response
```

### 5.2 Building a Wrapped Handler  

```python
from aiohttp import ClientSession
from aiohttp.client_middlewares import build_client_middlewares

async def main():
    async with ClientSession() as session:
        # The lowâ€‘level request coroutine that the session uses
        raw_handler = session._request   # typ: ClientHandlerType

        # Compose the middleware chain (you can supply many middlewares)
        wrapped_handler = build_client_middlewares(
            handler=raw_handler,
            middlewares=[add_header_middleware],
        )

        # Use the wrapped handler directly
        req = session._request  # normally you would construct a ClientRequest
        # Example call (the actual request construction is internal to aiohttp)
        # response = await wrapped_handler(req)
```

> **Note:** In everyday aiohttp usage you normally donâ€™t call `build_client_middlewares` yourself; the `ClientSession` constructor accepts a `request_class` or `raise_for_status` flags that internally perform this composition.

---

## 6. Notes for Developers  

| Topic | Guidance |
|-------|----------|
| **Performance** | The implementation avoids `functools.partial` and `functools.update_wrapper` to keep the perâ€‘request overhead minimal. The only extra allocation per middleware is the closure created inside `make_wrapper`. |
| **Reference Leakage** | No caching of the generated wrapper chain is performed. This prevents accidental retention of stateful middleware objects after a session is closed, but also means the wrapper is rebuilt each time `build_client_middlewares` is called. |
| **Ordering** | Middlewares are applied **in the order they appear in the sequence**; the first element becomes the outermost wrapper. The reverse iteration inside the function is crucial â€“ altering it will invert the intended order. |
| **Immutability of Arguments** | The `ClientRequest` object is passed *by reference*; a middleware may mutate its headers, query string, etc. Be cautious when sharing a request across concurrent coroutines. |
| **Error Propagation** | If a middleware raises (or returns a rejected coroutine), the exception bubbles up through the wrapper chain to the caller. No special try/except handling is performed here. |
| **Threadâ€‘Safety** | All constructs are pure async; there is no global mutable state, making the builder safe to use from multiple event loops as long as the underlying `handler` is itself threadâ€‘safe. |
| **Extensibility** | New middleware types can be added without changing this moduleâ€”just conform to the `ClientMiddlewareType` signature. |
| **Testing** | When unitâ€‘testing a custom middleware, you can provide a **dummy handler** (e.g., an async function returning a mock `ClientResponse`) and assert that the middleware receives the expected request and that the response is propagated correctly. |
| **Compatibility** | The module relies only on core `asyncio`/`collections.abc` and aiohttpâ€™s internal request/response objects, so it works across all supported Python versions for aiohttp (3.8+). |

---  

*End of documentation.*