# aiohappyeyeballs.utils – Utility Functions  

*Location*: `venv\Lib\site-packages\aiohappyeyeballs\utils.py`

---  

## 1. Module Purpose  

| Goal | Description |
|------|-------------|
| **Core responsibility** | Provide small, pure‑Python helpers that manipulate *address information* (`addr_info` tuples) used by the **aiohappyeyeballs** package – an implementation of the Happy Eyeballs algorithm for asyncio‑based TCP connections. |
| **Why it exists** | The Happy Eyeballs algorithm needs to interleave IPv4 and IPv6 connection attempts, remove addresses that have proven unusable, and translate between the various address tuple shapes returned by the standard library (`socket.getaddrinfo`, `sock.getpeername`, etc.). Centralising this logic in a dedicated module avoids duplication across the connection‑handling code and makes the behaviour unit‑testable. |

---  

## 2. Key Components  

| Component | Description | Signature & Types | Return | Public API? |
|-----------|-------------|-------------------|--------|--------------|
| **`addr_to_addr_infos`** | Normalises a single address tuple (as returned by `socket.getpeername` or similar) into the *addr_info* format that `asyncio` expects (`(family, type, proto, canonname, sockaddr)`). Supports IPv4 and IPv6 forms, handling optional `flowinfo` / `scopeid` for IPv6. | `def addr_to_addr_infos(addr: Optional[Union[Tuple[str, int, int, int], Tuple[str, int, int], Tuple[str, int]]]) -> Optional[List[AddrInfoType]]` | `None` if *addr* is `None`; otherwise a one‑element list containing the constructed `AddrInfoType`. | Yes – used by connection orchestration code to convert a concrete socket address into a list that can be processed by the Happy Eyeballs scheduler. |
| **`pop_addr_infos_interleave`** | Removes a limited number of `addr_info` entries from a list, guaranteeing that at most *interleave* entries per address family (IPv4/IPv6) are popped. This implements the “interleaving” step of the Happy Eyeballs algorithm – e.g. after trying the first IPv6 address, the next IPv4 address should be taken, etc. | `def pop_addr_infos_interleave(addr_infos: List[AddrInfoType], interleave: Optional[int] = None) -> None` | `None` (mutates *addr_infos* in‑place). | Yes – called by the connection‑retry loop to fetch the next batch of candidates. |
| **`_addr_tuple_to_ip_address`** *(private)* | Helper that converts a raw socket address tuple (`(host, port, ...)`) into a tuple whose first element is an `ipaddress.IPv4Address` or `ipaddress.IPv6Address`. This normalises string representation differences (e.g. `::1` vs `0:0:0:0:0:0:0:1`). | `def _addr_tuple_to_ip_address(addr: Union[Tuple[str, int], Tuple[str, int, int, int]]) -> Union[Tuple[ipaddress.IPv4Address, int], Tuple[ipaddress.IPv6Address, int, int, int]]` | Normalised tuple, preserving any extra IPv6 fields (`flowinfo`, `scopeid`). | No – internal use only, but important for `remove_addr_infos`. |
| **`remove_addr_infos`** | Removes all `addr_info` entries that reference a specific socket address (normally the peer address of a failed connection). It first attempts a direct tuple equality check; if that fails, it falls back to a “slow path” where the address strings are converted to `ipaddress` objects for a canonical comparison. Raises `ValueError` if the address cannot be found. | `def remove_addr_infos(addr_infos: List[AddrInfoType], addr: Union[Tuple[str, int], Tuple[str, int, int, int]]) -> None` | `None` (mutates *addr_infos* in‑place) or raises `ValueError`. | Yes – used by the retry controller to prune addresses that have already failed. |

### Types referenced  

* `AddrInfoType` – imported from `.types`. In the context of the standard library it matches the tuple format returned by `socket.getaddrinfo` (i.e. `(family, socktype, proto, canonname, sockaddr)`).  

---  

## 3. Dependencies & Relationships  

| Category | Items |
|----------|-------|
| **Standard‑library imports** | `ipaddress` – for canonical IP object representation.<br>`socket` – to obtain address family constants (`AF_INET`, `AF_INET6`) and socket‑type/protocol constants (`SOCK_STREAM`, `IPPROTO_TCP`). |
| **Project imports** | `from .types import AddrInfoType` – the local type alias used throughout the package. |
| **Internal usage** | All functions are pure utilities; they do **not** depend on any asyncio primitives directly but are called by higher‑level modules that implement the Happy Eyeballs connection logic (`aiohappyeyeballs.core`, `aiohappyeyeballs.connection`, etc.). |
| **Components that depend on this module** (inferred) | * Connection orchestration code that builds the candidate list (`addr_infos`) for parallel IPv4/IPv6 attempts. <br>* Retry or fallback mechanisms that need to drop a failed address (`remove_addr_infos`). <br>* Any test suite that validates address handling. |
| **How it fits in the architecture** | The Happy Eyeballs algorithm works with **candidate address lists**. `utils.py` supplies the canonical transformations and list‑manipulation primitives that keep those candidate lists consistent, enabling the rest of the library to focus on the concurrency/IO aspects. |

---  

## 4. Workflow Description  

1. **Normalising a raw address**  
   *When a socket is already connected (e.g. after a successful attempt), the code may need to turn the peer’s address into an `addr_info` entry.*  
   - Call `addr_to_addr_infos(addr)`.  
   - The function detects IPv6 by the presence of a colon (`:`) in the host string.  
   - For IPv6 it extracts `flowinfo` and `scopeid` (if present) and builds a 4‑tuple `(host, port, flowinfo, scopeid)`; family = `AF_INET6`.  
   - For IPv4 it builds a 2‑tuple `(host, port)`; family = `AF_INET`.  
   - Returns a list containing a single `AddrInfoType` tuple ready for consumption by the scheduler.

2. **Interleaving candidates**  
   *Before launching a new batch of parallel connection attempts, the scheduler wants to pop a limited number of entries per family.*  
   - `pop_addr_infos_interleave(addr_infos, interleave=n)` iterates over `addr_infos` in order.  
   - A `seen` dict tracks how many entries of each address family have already been marked for removal.  
   - Once a family has reached `interleave` hits, subsequent entries of that family are left untouched.  
   - The collected entries are removed *in a second loop* to avoid mutating the list while iterating.  

3. **Removing a failed address**  
   *If a connection attempt fails, the associated address must be eliminated from the remaining candidate pool.*  
   - `remove_addr_infos(addr_infos, addr)` first scans for an **exact tuple match** (`addr_info[-1] == addr`).  
   - If none are found, it converts both the supplied `addr` and each `addr_info`’s socket address to canonical `ipaddress` objects via `_addr_tuple_to_ip_address`.  
   - Matching canonical tuples are removed.  
   - If after both passes the address is still not present, a `ValueError` is raised – signalling a logic error in the caller.  

**Overall call flow (typical usage)**  

```
candidate_infos = socket.getaddrinfo(host, port, type=socket.SOCK_STREAM)
while candidate_infos:
    # Get the next interleaved batch (e.g. 1 per family)
    pop_addr_infos_interleave(candidate_infos, interleave=1)
    try:
        # Attempt connections using the popped batch (handled elsewhere)
        ...
        # On success, convert the peer address to a canonical AddrInfo
        success_info = addr_to_addr_infos(sock.getpeername())
        # Possibly merge back or finish
        break
    except ConnectionError:
        # Remove the address that just failed
        remove_addr_infos(candidate_infos, failed_peer_addr)
        continue
```

---  

## 5. Usage Examples  

### 5.1 Converting a `sock.getpeername()` result  

```python
import socket
from aiohappyeyeballs.utils import addr_to_addr_infos

# Example IPv4 socket address
ipv4_addr = ('93.184.216.34', 80)          # from sock.getpeername()
ipv4_infos = addr_to_addr_infos(ipv4_addr)
# ipv4_infos -> [(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP, '', ('93.184.216.34', 80))]

# Example IPv6 socket address (has flowinfo and scopeid)
ipv6_addr = ('2001:db8::1', 443, 0, 2)    # host, port, flowinfo, scopeid
ipv6_infos = addr_to_addr_infos(ipv6_addr)
# ipv6_infos -> [(socket.AF_INET6, socket.SOCK_STREAM, socket.IPPROTO_TCP,
#                '', ('2001:db8::1', 443, 0, 2))]
```

### 5.2 Interleaving candidate addresses  

```python
from aiohappyeyeballs.utils import pop_addr_infos_interleave

# Suppose we have a mixed list of AddrInfo tuples
candidates = [
    (socket.AF_INET6, socket.SOCK_STREAM, socket.IPPROTO_TCP, "", ('2001:db8::1', 443, 0, 0)),
    (socket.AF_INET,  socket.SOCK_STREAM, socket.IPPROTO_TCP, "", ('93.184.216.34', 443)),
    (socket.AF_INET6, socket.SOCK_STREAM, socket.IPPROTO_TCP, "", ('2001:db8::2', 443, 0, 0)),
    (socket.AF_INET,  socket.SOCK_STREAM, socket.IPPROTO_TCP, "", ('203.0.113.10', 443)),
]

# Retrieve one address per family (default interleave=1)
pop_addr_infos_interleave(candidates)   # modifies `candidates` in‑place

# `candidates` now contains the remaining entries:
# [
#   (AF_INET6, ..., ('2001:db8::2', 443, 0, 0)),
#   (AF_INET,  ..., ('203.0.113.10', 443)),
# ]
```

### 5.3 Removing a failed address  

```python
from aiohappyeyeballs.utils import remove_addr_infos

# Existing list of AddrInfo entries
addr_infos = [
    (socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP, "", ('93.184.216.34', 80)),
    (socket.AF_INET6, socket.SOCK_STREAM, socket.IPPROTO_TCP, "", ('2001:db8::1', 80, 0, 0)),
]

failed_addr = ('93.184.216.34', 80)      # address that just failed
remove_addr_infos(addr_infos, failed_addr)

# `addr_infos` now only contains the IPv6 entry
```

---  

## 6. Notes for Developers  

| Aspect | Detail |
|--------|--------|
| **Mutability** | All functions **mutate** the supplied `addr_infos` list in‑place. Callers must be aware that the original list is altered. |
| **Interleave semantics** | `pop_addr_infos_interleave` does **not** guarantee that the removed elements are contiguous; it simply respects the per‑family count. The order of the remaining list is preserved. |
| **IPv6 detection** | The implementation treats any host containing `:` as IPv6. This mirrors CPython’s `socket` heuristics but may misclassify malformed inputs; callers should validate addresses beforehand. |
| **Canonicalisation** | `_addr_tuple_to_ip_address` uses `ipaddress.ip_address`, which raises `ValueError` for non‑numeric host strings (e.g. DNS names). The function is only called after a direct equality miss, implying that the address being compared is already known to be an IP literal. |
| **Error handling** | `remove_addr_infos` raises `ValueError` when the target address cannot be found. In normal Happy Eyeballs operation this should never happen; a raised exception therefore indicates a programming error or a race condition where the address list changed concurrently. |
| **Thread‑/task‑safety** | The utilities themselves are stateless and therefore safe to use from multiple coroutines, **provided** the same mutable list isn’t accessed concurrently without external synchronisation. |
| **Future extensions** | If additional address families (e.g., `AF_BLUETOOTH`) ever need to be handled, the logic in `addr_to_addr_infos` and `pop_addr_infos_interleave` would need to be expanded – currently they assume exactly two families (IPv4/IPv6). |
| **Testing** | The functions are small and pure; they are excellent candidates for unit tests covering: <br>• IPv4 vs IPv6 handling, <br>• Various `interleave` values (including `None`/default), <br>• Both fast and slow removal paths in `remove_addr_infos`. |

---  

*End of documentation.*