# aiohttp.client_ws – WebSocket Client Implementation  

*File:* `venv\Lib\site-packages\aiohttp\client_ws.py`

---

## 1. Module Purpose  

### What this file is responsible for  
`aiohttp.client_ws` implements the **client‑side WebSocket protocol** for the `aiohttp` asynchronous HTTP library. It defines:

* A lightweight immutable timeout holder (`ClientWSTimeout`).  
* The main high‑level API object (`ClientWebSocketResponse`) that represents an open WebSocket connection returned by `ClientSession.ws_connect()`.  

The module handles framing, ping/pong heart‑beats, message receipt, automatic closure, and graceful shutdown while exposing a clean async API (`receive`, `send_*`, `ping`, `close`, etc.).

### Why it exists in the project  
`aiohttp` provides both HTTP client/server functionality and WebSocket support. The HTTP client builds a TCP connection, performs the upgrade handshake, and then hands control over to this module to manage the ongoing full‑duplex communication. Keeping the WebSocket logic in a dedicated file isolates protocol‑specific behaviour from the generic HTTP request/response handling, making the codebase easier to maintain and extend.

---

## 2. Key Components  

### 2.1 `ClientWSTimeout` (frozen `attr` class)

| Attribute | Type | Meaning |
|-----------|------|---------|
| `ws_receive` | `Optional[float]` | Timeout for a single `receive()` call. `None` disables the timeout. |
| `ws_close`   | `Optional[float]` | Timeout for waiting the server’s close frame after we sent our own close. |

*Immutable* (frozen) and uses `slots` for memory efficiency.  
**Public API:** Instantiated by library users or internally (`DEFAULT_WS_CLIENT_TIMEOUT`).

---

### 2.2 `ClientWebSocketResponse`

Represents a live WebSocket connection. It is **awaitable**, **async-iterable**, and can be used as an async context manager.

#### Constructor  

```python
def __init__(
    self,
    reader: WebSocketDataQueue,
    writer: WebSocketWriter,
    protocol: Optional[str],
    response: ClientResponse,
    timeout: ClientWSTimeout,
    autoclose: bool,
    autoping: bool,
    loop: asyncio.AbstractEventLoop,
    *,
    heartbeat: Optional[float] = None,
    compress: int = 0,
    client_notakeover: bool = False,
) -> None
```

* **Inputs**  
  * `reader` – queue that yields `WSMessage` objects (`WebSocketDataQueue`).  
  * `writer` – low‑level frame sender (`WebSocketWriter`).  
  * `protocol` – sub‑protocol negotiated during handshake.  
  * `response` – original `ClientResponse` that performed the upgrade.  
  * `timeout` – `ClientWSTimeout` instance controlling read/close timeouts.  
  * `autoclose` – if `True`, automatically send a close frame when a server‑initiated close is received.  
  * `autoping` – if `True`, automatically reply to incoming ping frames with a pong.  
  * `loop` – the event loop used for timers/tasks.  
  * `heartbeat` – optional interval (seconds) for sending periodic *ping* frames.  
  * `compress` – per‑message compression level (0 = disabled).  
  * `client_notakeover` – flag used by transport takeover logic (internal).  

* **Outputs** – No return value; internal state is set up (heartbeat timers, flags, etc.).

#### Public properties  

| Property | Type | Description |
|----------|------|-------------|
| `closed` | `bool` | Connection has been closed (no further I/O). |
| `close_code` | `Optional[int]` | WebSocket close code that was received or sent. |
| `protocol` | `Optional[str]` | Negotiated sub‑protocol. |
| `compress` | `int` | Compression level used for outbound frames. |
| `client_notakeover` | `bool` | Internal flag, exposed for compatibility. |

#### Public methods  

| Method | Signature | Purpose |
|--------|-----------|---------|
| `get_extra_info(name, default=None)` | `def get_extra_info(self, name: str, default: Any = None) -> Any` | Proxy to the underlying transport’s `get_extra_info`. |
| `exception()` | `def exception(self) -> Optional[BaseException]` | Returns the first exception that caused the socket to close, if any. |
| `ping(message=b'')` | `async def ping(self, message: bytes = b'') -> None` | Sends a **PING** frame. |
| `pong(message=b'')` | `async def pong(self, message: bytes = b'') -> None` | Sends a **PONG** frame. |
| `send_frame(message, opcode, compress=None)` | `async def send_frame(self, message: bytes, opcode: WSMsgType, compress: Optional[int] = None) -> None` | Low‑level frame transmission (any opcode). |
| `send_str(data, compress=None)` | `async def send_str(self, data: str, compress: Optional[int] = None) -> None` | Sends a UTF‑8 text frame (`WSMsgType.TEXT`). |
| `send_bytes(data, compress=None)` | `async def send_bytes(self, data: bytes, compress: Optional[int] = None) -> None` | Sends a binary frame (`WSMsgType.BINARY`). |
| `send_json(data, compress=None, *, dumps=DEFAULT_JSON_ENCODER)` | `async def send_json(self, data: Any, compress: Optional[int] = None, *, dumps: JSONEncoder = DEFAULT_JSON_ENCODER) -> None` | Serialises *data* to JSON and sends as a text frame. |
| `close(*, code=WSCloseCode.OK, message=b'')` | `async def close(self, *, code: int = WSCloseCode.OK, message: bytes = b'') -> bool` | Initiates an orderly shutdown, optionally waiting for the server’s close frame. Returns `True` if a close was performed, `False` if already closed. |
| `receive(timeout=None)` | `async def receive(self, timeout: Optional[float] = None) -> WSMessage` | Waits for the next **non‑internal** WebSocket message (text, binary, ping, pong, close). Handles automatic ping/pong, auto‑close, heart‑beat resetting, and error conversion. |
| `receive_str(*, timeout=None)` | `async def receive_str(self, *, timeout: Optional[float] = None) -> str` | Convenience wrapper that ensures the received message is `TEXT`. |
| `receive_bytes(*, timeout=None)` | `async def receive_bytes(self, *, timeout: Optional[float] = None) -> bytes` | Convenience wrapper that ensures the received message is `BINARY`. |
| `receive_json(*, loads=DEFAULT_JSON_DECODER, timeout=None)` | `async def receive_json(self, *, loads: JSONDecoder = DEFAULT_JSON_DECODER, timeout: Optional[float] = None) -> Any` | Convenience wrapper that receives a text frame and parses it as JSON. |

#### Async iterator protocol  

* `__aiter__` returns `self`.  
* `__anext__` awaits `receive()` and raises `StopAsyncIteration` when the socket is closed.  

#### Async context manager  

* `__aenter__` returns the instance.  
* `__aexit__` ensures the socket is closed (`await self.close()`).  

---

#### Internal helper methods  

| Method | Visibility | Short description |
|--------|------------|-------------------|
| `_reset_heartbeat` | private | (Re)‑schedule the next periodic **ping** based on the configured `heartbeat` interval. |
| `_cancel_heartbeat` | private | Cancel both the ping timer and the pong‑timeout timer. |
| `_send_heartbeat` | private | Send a **PING** frame, schedule a pong‑timeout callback and keep a reference to the ping task for error handling. |
| `_ping_task_done` | private | Callback when a ping task completes; forwards any exception to `_handle_ping_pong_exception`. |
| `_pong_not_received` | private | Called when pong timeout expires – treats it as a server‑side timeout error. |
| `_handle_ping_pong_exception` | private | Centralises error handling for ping/pong failures – closes the socket, records the exception, and propagates an `ERROR` WSMessage to the reader if a consumer is waiting. |
| `_set_closed` / `_set_closing` | private | Update internal flags and cancel heart‑beat timers. |
| `_cancel_pong_response_cb` | private | Cancels the timer waiting for a pong response. |

These methods implement the **heartbeat/ping‑pong** logic, ensuring the connection is kept alive (or correctly terminated) when the remote side is unresponsive.

---

### 2.3 Module‑level constants  

| Name | Value | Meaning |
|------|-------|---------|
| `DEFAULT_WS_CLIENT_TIMEOUT` | `ClientWSTimeout(ws_receive=None, ws_close=10.0)` | Default timeout settings applied when a user does not supply a custom `ClientWSTimeout`. |

---

## 3. Dependencies & Relationships  

### Imports  

| Module | Used for |
|--------|----------|
| `asyncio` | Event‑loop primitives, tasks, timers, cancellation, timeouts. |
| `sys` | Version check for `async_timeout` import. |
| `types.TracebackType` | Type hint for `__aexit__`. |
| `typing` (`Any`, `Optional`, `Type`, `cast`) | Static typing. |
| `attr` | Declaration of immutable `ClientWSTimeout`. |
| `. _websocket.reader.WebSocketDataQueue` | Queue that yields `WSMessage` objects. |
| `.client_exceptions` (`ClientError`, `ServerTimeoutError`, `WSMessageTypeError`) | Exception hierarchy used throughout. |
| `.client_reqrep.ClientResponse` | Original HTTP response that performed the upgrade. |
| `.helpers` (`calculate_timeout_when`, `set_result`) | Helper utilities for timing and future resolution. |
| `.http` (`WS_CLOSED_MESSAGE`, `WS_CLOSING_MESSAGE`, `WebSocketError`, `WSCloseCode`, `WSMessage`, `WSMsgType`) | Core WebSocket protocol structures and constants. |
| `.http_websocket` (`_INTERNAL_RECEIVE_TYPES`, `WebSocketWriter`) | Writer implementation and set of internal message types (e.g., ping/pong/close). |
| `.streams.EofStream` | Raised when the underlying transport reaches EOF. |
| `.typedefs` (`DEFAULT_JSON_DECODER`, `DEFAULT_JSON_ENCODER`, `JSONDecoder`, `JSONEncoder`) | JSON (de)serialization defaults and types. |
| `async_timeout` (conditional import) | Context manager that raises `asyncio.TimeoutError` after a deadline. |

### Interaction with other parts of **aiohttp**  

* **Upstream:**  
  * `ClientSession.ws_connect()` creates the TCP connection, runs the HTTP upgrade handshake, then constructs a `WebSocketDataQueue`, `WebSocketWriter`, and finally a `ClientWebSocketResponse`.  
  * The `ClientResponse` object (passed as `response`) supplies the underlying transport and is closed when the WebSocket ends.

* **Downstream:**  
  * Application code consumes the object via `await ws.receive()`, `await ws.send_str()`, or by iterating `async for msg in ws`.  
  * Other aiohttp internals (e.g., connection pool, closing logic) interact with the underlying transport via `self._response.close()` when the socket terminates.

* **External:**  
  * This module does **not** expose any classes outside the package other than `ClientWebSocketResponse` and `ClientWSTimeout`. Users obtain instances only through the public API (`ClientSession.ws_connect`).

### Architectural role  

* **Layer:** Transport‑level protocol handling (layer 5 of the OSI model).  
* **Responsibility:** Convert raw frames to high‑level `WSMessage` objects, manage ping/pong/heartbeat, enforce timeouts, expose a clean coroutine‑based API.  
* **Isolation:** Keeps WebSocket specifics separate from generic HTTP handling, allowing reuse of the same connection pool and transport machinery.

---

## 4. Workflow Description  

Below is a **step‑by‑step** description of the typical lifecycle of a `ClientWebSocketResponse`.

1. **Construction** (`ClientWebSocketResponse.__init__`)  
   * Store references to `reader`, `writer`, `response`, timeout settings, and flags.  
   * Initialise heartbeat timers if `heartbeat` is provided (`_reset_heartbeat`).  

2. **Heartbeat scheduling** (`_reset_heartbeat`)  
   * Compute the next fire time using `calculate_timeout_when`.  
   * Schedule `_send_heartbeat` via `loop.call_at`.  

3. **Sending a heartbeat** (`_send_heartbeat`)  
   * Verify the scheduled time is not in the past; if it is, reschedule.  
   * Schedule a pong‑timeout callback (`_pong_not_received`) based on `self._pong_heartbeat`.  
   * Send a **PING** frame using `self._writer.send_frame`.  
   * Keep the task reference (`self._ping_task`) to propagate any exception (`_ping_task_done`).  

4. **Receiving messages** (`receive`)  
   * Guard against concurrent calls (`self._waiting`).  
   * If the socket is already closed/closing, return/close appropriately.  
   * Optionally apply a receive timeout (`async_timeout.timeout`).  
   * Read a `WSMessage` from the queue (`self._reader.read`).  
   * Reset the heartbeat timer after successful read.  

5. **Message handling loop** (inside `receive`)  
   * **Application data** (`TEXT`, `BINARY`, `ERROR`, etc.): returned immediately.  
   * **Control frames** (`CLOSE`, `CLOSING`, `PING`, `PONG`) are processed:  
     * **CLOSE** – set closing flag, store code, maybe auto‑close.  
     * **CLOSING** – set closing flag, wait for final close.  
     * **PING** – if `autoping` is enabled, reply with `pong`.  
     * **PONG** – if `autoping` is enabled, ignore (the pong‑timeout timer is already cleared).  

6. **Automatic close** (`close`)  
   * If another coroutine is awaiting `receive`, a *future* (`_close_wait`) is created; the current coroutine feeds a `WS_CLOSING_MESSAGE` to break the read loop.  
   * Calls `self._writer.close` to send the close frame.  
   * Waits (with timeout) for the server’s close frame (`WSMsgType.CLOSE`).  
   * Cleans up timers, marks connection closed, and closes the underlying `ClientResponse`.  

7. **Error handling**  
   * All network‑level exceptions (`ClientError`, `EofStream`, `WebSocketError`, generic `Exception`) funnel through dedicated branches that set `self._closed` / `self._closing`, populate `self._exception`, and optionally feed an `ERROR` message to the reader queue.  

8. **Termination**  
   * When the connection reaches a closed state, `closed` returns `True`.  
   * Async iterator (`__anext__`) raises `StopAsyncIteration`.  
   * The async context manager (`__aexit__`) guarantees `close()` is called.  

---

## 5. Usage Examples  

The public API is intended to be used via **aiohttp**’s `ClientSession`. Below are typical patterns that can be inferred from the methods exposed by `ClientWebSocketResponse`.

### 5.1 Simple echo client  

```python
import aiohttp
import asyncio

async def echo():
    async with aiohttp.ClientSession() as session:
        async with session.ws_connect('wss://example.com/echo') as ws:
            await ws.send_str('hello')
            msg = await ws.receive()
            if msg.type == aiohttp.WSMsgType.TEXT:
                print('Server replied:', msg.data)

asyncio.run(echo())
```

### 5.2 JSON exchange with automatic serialization  

```python
async def json_client():
    async with aiohttp.ClientSession() as session:
        async with session.ws_connect('wss://api.example.com/ws') as ws:
            await ws.send_json({'action': 'subscribe', 'channel': 'ticker'})
            reply = await ws.receive_json()
            print('Subscribed, server replied:', reply)
```

### 5.3 Using the asynchronous iterator  

```python
async def stream_messages():
    async with aiohttp.ClientSession() as session:
        async with session.ws_connect('wss://stream.example.com/') as ws:
            async for msg in ws:
                print('Got:', msg.type, msg.data)
```

### 5.4 Enabling heartbeat (ping)  

```python
timeout = aiohttp.ClientWSTimeout(ws_receive=30)
async with aiohttp.ClientSession() as session:
    async with session.ws_connect(
        'wss://live.example.com/',
        timeout=timeout,
        heartbeat=15,          # send a ping every 15 s
        autoping=True,        # automatically reply to pings
    ) as ws:
        # normal operation …
        await ws.send_str('ready')
```

---

## 6. Notes for Developers  

### 6.1 Concurrency constraints  

* **Single consumer** – `receive()` must not be called concurrently. The implementation raises `RuntimeError` if `_waiting` is already `True`. This restriction simplifies internal state handling (e.g., heartbeat reset) and avoids race conditions.  

### 6.2 Heartbeat implementation  

* **Timer churn optimisation** – `_reset_heartbeat` deliberately avoids cancelling an existing heartbeat `TimerHandle`. Instead, `_send_heartbeat` checks the scheduled time and reschedules if it fired too early. This reduces the number of heap operations inside the asyncio event loop, which can be a noticeable overhead in high‑frequency scenarios.  

* **Python 3.12 optimisation** – When creating the ping coroutine task, the code uses `asyncio.Task(..., eager_start=True)` to start the task immediately, bypassing an extra loop iteration. This is a minor performance win on newer Python versions.  

### 6.3 Exception handling strategy  

* Any exception that occurs while sending a ping (`_handle_ping_pong_exception`) forces the socket into a closed state, records the exception, and pushes an `ERROR` message into the reader queue if a consumer is awaiting. This gives the user a deterministic way to discover the cause of a failure.  

* In `close()`, the method distinguishes between **cancellation** (`asyncio.CancelledError`) – which propagates – and other exceptions, which result in an abnormal closure (`WSCloseCode.ABNORMAL_CLOSURE`).  

### 6.4 Timeout semantics  

* **Receive timeout** (`ws_receive`) is applied *per* `receive()` call. A `None` value means “wait indefinitely”.  

* **Close timeout** (`ws_close`) is used only after we have sent our own close frame; we wait for the server’s close frame for at most that duration.  

* The **heartbeat** interval is independent of the receive timeout; the heartbeat timer is calculated with `calculate_timeout_when`, which also respects the connector’s global timeout‑ceil threshold (default 5 s).  

### 6.5 Compression  

* The `compress` argument is stored but never interpreted in this file; it is passed down to the underlying `WebSocketWriter`. The client can therefore request per‑message compression (e.g., `compress=1` for “deflate”).  

### 6.6 Lifecycle edge cases  

* If `close()` is invoked while another coroutine is blocked in `receive()`, a *future* (`_close_wait`) is used to synchronize the two tasks. The waiting `receive()` receives a `WS_CLOSING_MESSAGE`, wakes up, and the `close()` coroutine proceeds.  

* The `autoclose` flag determines whether an incoming close frame automatically triggers a graceful close reply; disabling it lets the application decide when to send its own close.  

### 6.7 Testing considerations  

* Heartbeat logic relies on the event loop’s time (`loop.time()`). When writing unit tests, consider mocking `loop.time` or using `asyncio.EventLoopPolicy` to control timing, otherwise tests may become flaky due to real‑time dependencies.  

* The class uses many **private** helpers; tests should focus on the public API (`receive`, `send_*`, `close`, iteration) and assert state via properties (`closed`, `close_code`, `exception`).  

---

*End of documentation.*