# `jsonpointer.py` – JSON Pointer Implementation (RFC 6901)

## 1. Module Purpose
`jsonpointer.py` provides a **pure‑Python implementation of the JSON Pointer syntax** defined in RFC 6901.  
Its responsibilities are:

| Responsibility | Why it exists |
|----------------|----------------|
| Parse, validate, and represent a JSON Pointer string | Guarantees that only syntactically‑correct pointers are used throughout the project. |
| Resolve a pointer against any JSON‑compatible document (dicts, lists, custom objects that implement `__getitem__`) | Enables safe, deterministic navigation to a specific node inside a JSON document. |
| Mutate a document at the location indicated by a pointer | Allows convenient “set‑in‑place” operations without the caller needing to manually traverse the structure. |
| Utility helpers (`escape`, `unescape`, `pairwise`) | Support the pointer encoding rules and internal algorithms. |

Typical callers are higher‑level libraries that need to read, modify, or validate parts of a JSON payload (e.g., a JSON‑Patch implementation, a configuration system, or a REST API that works with JSON fragments).

---

## 2. Key Components

### 2.1 Public Functions  

| Function | Signature | Description |
|----------|-----------|-------------|
| **`set_pointer(doc, pointer, value, inplace=True)`** | `doc: Any`, `pointer: str | JsonPointer`, `value: Any`, `inplace: bool = True` → `Any` | Resolves *pointer* against *doc* and replaces the targeted node with *value*. If `inplace` is `True` (default) the original *doc* is mutated **unless** the pointer targets the document root, in which case a new document is returned. |
| **`resolve_pointer(doc, pointer, default=_nothing)`** | `doc: Any`, `pointer: str | JsonPointer`, `default: Any = _nothing` → `Any` | Returns the object referenced by *pointer* inside *doc*. If the pointer cannot be resolved and *default* is provided, that value is returned; otherwise a `JsonPointerException` propagates. |
| **`pairwise(iterable)`** | `iterable: Iterable[T]` → `Iterator[Tuple[T, T]]` | Turns an iterable into a series of overlapping 2‑tuples: `(s0,s1), (s1,s2), …`. Used internally for potential future extensions, but currently exposed as a utility. |
| **`escape(s)`** | `s: str` → `str` | Encodes a raw JSON‑pointer token by replacing `~` with `~0` and `/` with `~1`. |
| **`unescape(s)`** | `s: str` → `str` | Decodes an escaped token back to its literal representation. |

#### Remarks on inputs/outputs
* `doc` can be any mapping, sequence, or an object that implements `__getitem__`.  
* `pointer` may be a raw JSON‑Pointer string **or** an already‑instantiated `JsonPointer`.  
* The special sentinel `_nothing` (a unique object) differentiates “no default supplied” from a user‑provided default value of `None`.

---

### 2.2 Exceptions  

| Class | Description |
|-------|-------------|
| **`JsonPointerException`** | Base exception raised for any pointer‑related error: malformed pointer, invalid escape, out‑of‑bounds index, missing key, or unsupported document type. |
| **`EndOfList`** | Wrapper used when the special list token `"-"` is accessed. It stores the original list (`list_`) and signals “append‑position” semantics to callers of `walk`. |

---

### 2.3 Core Class – `JsonPointer`

| Attribute / Method | Signature | Purpose |
|--------------------|-----------|---------|
| `__init__(self, pointer: str)` | – | Parses *pointer*, validates escape sequences (`~0`, `~1`), splits on `/`, unescapes each token, and stores them in `self.parts`. Raises `JsonPointerException` on malformed input. |
| `to_last(self, doc: Any) -> Tuple[Any, Any]` | – | Walks the document up to *but not including* the final token. Returns `(parent_doc, last_part)`. If the pointer is empty, returns `(doc, None)`. |
| `resolve(self, doc: Any, default: Any = _nothing) -> Any` | – | Traverses the document using every token in `self.parts`. Returns the final value or *default* (if supplied) when traversal fails. |
| `set(self, doc: Any, value: Any, inplace: bool = True) -> Any` | – | Replaces the node addressed by the pointer with *value*. Handles the special `"-"` list token (append). Returns the possibly‑mutated document. |
| `get_part(cls, doc: Any, part: str) -> Union[str, int]` (class method) | – | Determines the correct Python index type for *part* based on the document type: strings for mappings, integers for sequences (validating RFC‑compliant numeric tokens). |
| `walk(self, doc: Any, part: str) -> Any` | – | Retrieves the sub‑document indicated by a *single* token, delegating to `get_part`. Raises `JsonPointerException` on missing keys or out‑of‑range indices. |
| `contains(self, ptr: JsonPointer) -> bool` | – | Returns `True` if this pointer is a prefix of *ptr*. |
| `join(self, suffix: Union[JsonPointer, str, Iterable]) -> JsonPointer` | – | Returns a new `JsonPointer` representing the concatenation of the current pointer with *suffix*. |
| `__truediv__(self, suffix)` | – | Syntactic sugar allowing the `/` operator (`ptr / '/a/b'`). |
| `path` (property) | – | Returns the canonical string representation (escaped) of the pointer, e.g. `'/foo~0/bar'`. |
| `from_parts(cls, parts: Iterable) -> JsonPointer` (class method) | – | Builds a pointer from a sequence of **unescaped** path components. Useful when constructing pointers programmatically. |
| `__eq__`, `__hash__`, `__str__`, `__repr__` | – | Standard dunder methods for equality, hashing, string conversion, and debugging. |

#### Public API Surface
* The **public** entry points are `set_pointer`, `resolve_pointer`, `pairwise`, `escape`, `unescape`, and the `JsonPointer` class (including its methods `resolve`, `set`, `join`, `from_parts`, etc.).  
* All other helpers (`_nothing`, `EndOfList`, `JsonPointerException`) are part of the module’s contract for error handling and special‑case signaling.

---

## 3. Dependencies & Relationships

### 3.1 Imports
| Module | Reason |
|--------|--------|
| `copy` | Enables deep‑copying of a document when `inplace=False` in `JsonPointer.set`. |
| `re` | Regular‑expression validation of array indices (`_RE_ARRAY_INDEX`) and illegal escape sequences (`_RE_INVALID_ESCAPE`). |
| `collections.abc.Mapping`, `collections.abc.Sequence` | Abstract base classes used to detect dict‑like vs. list‑like structures. |
| `itertools.tee`, `itertools.chain` | Implement `pairwise` (splitting an iterable) and `join` (concatenating pointer parts). |

### 3.2 Interaction with the Rest of the Project
* **Clients**: Any module that needs to locate or replace a value inside a JSON document (e.g., a JSON‑Patch processor, configuration loader). They import `resolve_pointer`/`set_pointer` or instantiate `JsonPointer` directly.
* **Providers**: This file does **not** depend on other project‑specific modules; it is a self‑contained utility that can be used anywhere a JSON document is present.
* **Potential Consumers**:  
  * `jsonpatch.py` (if present) – would use `resolve_pointer` for “test” operations and `set_pointer` for “add”, “replace”, etc.  
  * Validation or schema libraries – may resolve `$ref` JSON Pointers.

### 3.3 Architectural Role
`jsonpointer.py` sits at the **infrastructure layer**, offering a low‑level primitive that higher‑level JSON manipulation components rely on. Because it is pure‑Python and has no external dependencies beyond the standard library, it can be imported in any environment (including embedded or constrained runtimes).

---

## 4. Workflow Description  

### 4.1 Pointer Construction (`JsonPointer.__init__`)
1. **Escape validation** – uses `_RE_INVALID_ESCAPE` to detect malformed `~` sequences; raises `JsonPointerException` if found.
2. **Splitting** – the string is split on `'/'`. The first element must be empty (pointer must start with `/` or be empty for the root).
3. **Unescaping** – each token is passed through `unescape` (replaces `~1` → `/` and `~0` → `~`).
4. **Store** – the resulting list of raw tokens is saved as `self.parts`.

### 4.2 Resolving a Pointer (`JsonPointer.resolve`)
For each token in `self.parts` (in order):
1. Call `self.walk(current_doc, token)`.
2. `walk` first determines the proper key type via `get_part`:
   * Mapping → token stays a string.
   * Sequence → token must match `_RE_ARRAY_INDEX` or be `'-'`; returns `int(token)` or the literal `'-'`.
3. Access the document (`doc[part]`):
   * Sequence: normal index or `EndOfList` for `'-'`.
   * Mapping / custom `__getitem__`: standard lookup.
4. If any step fails (missing key, out‑of‑range, unsupported document), a `JsonPointerException` propagates unless a *default* value was supplied, in which case the default is returned instantly.

### 4.3 Setting a Value (`JsonPointer.set`)
1. **Root case** – If the pointer is empty (`''`), the whole document is replaced (or returned as the new value if `inplace=False`).
2. **Copy (optional)** – When `inplace=False`, `copy.deepcopy` creates an isolated copy of the original document.
3. **Locate parent** – `to_last` walks until the element *before* the final token, returning `(parent, last_part)`.
4. **Write** –  
   * If `parent` is a `Sequence` and the last token is `'-'`, `append(value)`.  
   * Otherwise, assign via `parent[last_part] = value`.
5. Return the (potentially mutated) document.

### 4.4 Utility Functions
* **`pairwise`** – builds an iterator of overlapping pairs using `itertools.tee`.
* **`escape` / `unescape`** – perform the RFC‑6901 token transformation.
* **`join` / `__truediv__`** – concatenate pointers, handling both string and `JsonPointer` arguments.

---

## 5. Usage Examples  

### 5.1 Resolving a value
```python
from jsonpointer import resolve_pointer

doc = {
    "user": {
        "name": "Alice",
        "tags": ["admin", "beta"]
    }
}

# simple lookup
name = resolve_pointer(doc, "/user/name")            # → "Alice"

# list index
first_tag = resolve_pointer(doc, "/user/tags/0")      # → "admin"

# non‑existent path with a default
missing = resolve_pointer(doc, "/user/age", default=None)  # → None
```

### 5.2 Setting a value (in‑place)
```python
from jsonpointer import set_pointer

doc = {"settings": {"volume": 10}}

# increase volume
new_doc = set_pointer(doc, "/settings/volume", 20)   # doc is mutated, new_doc is same object
```

### 5.3 Appending to a list using the “-” token
```python
from jsonpointer import set_pointer

doc = {"items": [1, 2]}

# Append a new element
set_pointer(doc, "/items/-", 3)   # doc["items"] becomes [1, 2, 3]
```

### 5.4 Building a pointer programmatically
```python
from jsonpointer import JsonPointer

ptr = JsonPointer.from_parts(["users", 5, "email"])
ptr.path          # → "/users/5/email"
value = ptr.resolve(data_structure)
```

### 5.5 Combining pointers with the `/` operator
```python
base = JsonPointer("/a/b")
full = base / "c/d"          # equivalent to JsonPointer("/a/b/c/d")
```

---

## 6. Notes for Developers  

| Concern | Details |
|---------|----------|
| **Root pointer (`''`)** | Setting the root in‑place is prohibited (`JsonPointerException`). Use `set_pointer(..., inplace=False)` to replace the whole document. |
| **Array index validation** | Only decimal integers without leading zeros (`0` or `[1-9][0-9]*`) are accepted. Tokens like `"01"` or `"+2"` raise `JsonPointerException`. |
| **Special list token `"-"`** | Represents “append after the last element”. The `walk` method returns an `EndOfList` instance; `set` interprets it as `list.append(value)`. |
| **Custom objects** | Any object exposing `__getitem__` can be navigated as if it were a mapping or sequence. No further validation is performed. |
| **Escaping rules** | `escape` → `~` → `~0`, `/` → `~1`. `unescape` performs the inverse. Invalid escape sequences (`~` not followed by `0` or `1`) raise `JsonPointerException` early. |
| **Thread‑safety** | Functions are pure (except for optional in‑place mutation). When `inplace=True`, callers must ensure external synchronization if the same document is accessed from multiple threads. |
| **Performance** | `set_pointer` creates a deep copy only when `inplace=False`. Traversal is O(N) where N = number of pointer parts. No caching of resolved sub‑structures—re‑resolution each call. |
| **Error handling** | `JsonPointerException` is the only custom exception; it propagates upward unless a *default* is supplied to `resolve_pointer`. Users should catch this exception when dealing with user‑supplied pointers. |
| **Extensibility** | Adding support for additional document types (e.g., `numpy.ndarray`) only requires implementing `__getitem__` in a compatible way; no changes to this module are required. |
| **Testing** | The module includes doctests in docstrings (e.g., examples for `pairwise`, `set_pointer`, `resolve_pointer`). These should be kept as regression tests. |

--- 

*End of documentation.*