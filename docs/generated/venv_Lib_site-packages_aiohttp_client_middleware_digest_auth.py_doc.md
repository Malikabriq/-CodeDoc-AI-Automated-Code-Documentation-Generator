# aiohttp – `client_middleware_digest_auth.py`

## 1. Module Purpose
**What the file does**  
This module implements *HTTP Digest Authentication* (RFC 7616) as a client‑side middleware for **aiohttp**.  
When a request receives a **401 Unauthorized** response containing a `WWW‑Authenticate: Digest …` challenge, the middleware:

1. Parses the challenge parameters.  
2. Computes the digest response (including handling of algorithm variants, QoP, nonce counts, client nonces, etc.).  
3. Retries the original request automatically with a proper `Authorization: Digest …` header.  

**Why it exists**  
Digest authentication is a more secure alternative to Basic authentication because it never transmits the password in clear text. aiohttp ships with a pluggable middleware system; this file provides a ready‑to‑use middleware that integrates seamlessly with `aiohttp.ClientSession`, allowing developers to protect HTTP calls without manual header handling.

---

## 2. Key Components

| Component | Role | Public API | Main Logic |
|-----------|------|------------|------------|
| **Constants** |   |   |   |
| `DigestFunctions` | Mapping of supported algorithm names → hash constructors. | – | Used to select the hash function (`MD5`, `SHA-256`, …) for the digest calculation. |
| `_HEADER_PAIRS_PATTERN` | Compiled regex for parsing `key="value"` or `key=value` pairs. | – | Handles quoted strings, escaped quotes, and commas inside quotes. |
| `CHALLENGE_FIELDS` | Ordered tuple of RFC‑7616 challenge fields. | – | Determines which parameters are extracted from the `WWW‑Authenticate` header. |
| `SUPPORTED_ALGORITHMS` | Sorted tuple of algorithm names that the middleware recognises. | – | Used in error messages when an unsupported algorithm is encountered. |
| `QUOTED_AUTH_FIELDS` | Set of header fields that must be quoted in the `Authorization` header. | – | Drives the template construction of the final header. |
| **Utility Functions** |   |   |   |
| `escape_quotes(value: str) -> str` | Escapes `"` characters for inclusion in HTTP header values. | Public (module‑level) | `value.replace('"', '\\"')`. |
| `unescape_quotes(value: str) -> str` | Reverses `escape_quotes`. | Public (module‑level) | `value.replace('\\"', '"')`. |
| `parse_header_pairs(header: str) -> Dict[str, str]` | Parses a `WWW‑Authenticate` header into a dict of *key → value*. | Public (module‑level) | Uses `_HEADER_PAIRS_PATTERN.findall`, strips keys, and returns unescaped values. |
| **Class `DigestAuthMiddleware`** | The core middleware that performs the whole digest workflow. | Instantiable; callable (`await middleware(request, handler)`). | See methods below. |
| `__init__(login: str, password: str, preemptive: bool = True)` | Stores credentials, initialises state, and decides whether to send auth pre‑emptively. | Public constructor. | - Validates inputs (no `None`, username cannot contain `:`). <br>- Stores `login`/`password` as bytes.<br>- Initializes nonce tracking, challenge dict, protection‑space list, and pre‑emptive flag. |
| `_encode(self, method: str, url: URL, body: Union[Payload, Literal[b""]]) -> str` | **Internal** – builds the full `Authorization: Digest …` header for the current challenge. | Private (called by `__call__`). | 1. Validates required challenge fields (`realm`, `nonce`). <br>2. Normalises algorithm name, parses QoP, selects hash function. <br>3. Computes `HA1` and `HA2` per RFC 7616 (including `auth-int` handling). <br>4. Manages nonce count (`nc`) and client nonce (`cnonce`). <br>5. Handles session‑based algorithm (`*-SESS`). <br>6. Calculates the response digest (`KD`). <br>7. Constructs the header string, quoting fields defined in `QUOTED_AUTH_FIELDS`. |
| `_in_protection_space(self, url: URL) -> bool` | Checks whether a request URL belongs to the current *protection space* (the set of URIs that share the same authentication realm). | Private. | Iterates over stored `self._protection_space` strings and validates prefix rules. |
| `_authenticate(self, response: ClientResponse) -> bool` | Examines a `401` response; if it contains a Digest challenge, extracts parameters and updates internal state. | Private. | 1. Verifies status code 401 and presence of `WWW-Authenticate`. <br>2. Ensures the scheme is `Digest`. <br>3. Parses the header with `parse_header_pairs`. <br>4. Populates `self._challenge` with recognized fields. <br>5. Derives the *protection space* from the optional `domain` directive or defaults to the response origin. <br>6. Returns `True` if a usable challenge was found (causing a retry). |
| `__call__(self, request: ClientRequest, handler: ClientHandlerType) -> ClientResponse` | Middleware entry point – invoked by aiohttp for each request. | Public; conforms to `ClientHandlerType`. | 1. Loops up to two attempts (original + one retry). <br>2. Adds `Authorization` header when (a) retrying after 401 **or** (b) pre‑emptive mode is enabled **and** the request URL lies in the protection space. <br>3. Calls the downstream handler to obtain a response. <br>4. Calls `_authenticate` to decide if a retry is needed. <br>5. Returns the final `ClientResponse`. |

---

## 3. Dependencies & Relationships

| Import | Origin | Purpose |
|--------|--------|--------|
| `hashlib` | Python stdlib | Provides hash constructors for MD5, SHA‑1, SHA‑256, SHA‑512. |
| `os` | stdlib | Used for `os.urandom` in client‑nonce generation. |
| `re` | stdlib | Compiles regex for header parsing. |
| `time` | stdlib | Supplies a timestamp for `cnonce` randomness. |
| `typing` (`Callable`, `Dict`, …) | stdlib | Type hints for public API and internal helpers. |
| `yarl.URL` | aiohttp dependency | Represents URLs; used for path extraction and origin handling. |
| `.hdrs` | aiohttp internal | Constants for HTTP header names (`AUTHORIZATION`). |
| `.client_exceptions.ClientError` | aiohttp | Raised for malformed challenges or unsupported algorithms. |
| `.client_middlewares.ClientHandlerType` | aiohttp | Type alias for the callable that processes a request and returns a response. |
| `.client_reqrep.ClientRequest`, `ClientResponse` | aiohttp | Core request/response objects that flow through the middleware. |
| `.payload.Payload` | aiohttp | Represents request bodies; needed for `auth-int` QoP. |

### Interaction with the rest of the project
- **Consumes**: `ClientRequest`, `ClientResponse`, `Payload`, header constants, and the generic middleware handler from aiohttp.
- **Provides**: A callable object (`DigestAuthMiddleware`) that can be added to `ClientSession`’s `middlewares` sequence. It does **not** expose any other public symbols.
- **Potential callers**: Application code that creates an `aiohttp.ClientSession` and needs digest authentication:
  ```python
  session = aiohttp.ClientSession(middlewares=[DigestAuthMiddleware('user', 'pwd')])
  ```
- **Dependents**: Anything that builds a client session with this middleware. The middleware itself does not expose callbacks for external consumption beyond the standard aiohttp middleware interface.

---

## 4. Workflow Description

1. **Session creation** – user instantiates `DigestAuthMiddleware` with credentials (and optional `preemptive=True/False`).  
2. **First request** – aiohttp calls the middleware (`__call__`).  
   - `retry_count == 0`.  
   - If **preemptive** mode is `True` **and** a previous challenge exists that matches the request URL (`_in_protection_space`), the middleware adds an `Authorization` header generated by `_encode`.  
   - Request is forwarded to the next handler (`handler(request)`).  
3. **Response handling** – the middleware receives a `ClientResponse`.  
   - `_authenticate` checks for status **401** and a `WWW-Authenticate` header with the `Digest` scheme.  
   - If present, it parses the challenge, fills `self._challenge`, determines the protection space, and returns `True`.  
   - If the response is not a digest challenge, `_authenticate` returns `False`.  
4. **Retry (if needed)** – when `_authenticate` returned `True`, the loop iterates (`retry_count == 1`).  
   - Now the middleware **must** add an `Authorization` header (the request is a retry). `_encode` builds the header using the stored challenge, incrementing the nonce count and generating a fresh `cnonce`.  
   - The request (with auth) is sent again via `handler`.  
5. **Final response** – after the second attempt, `_authenticate` is called again.  
   - If the server still returns 401, the loop exits (no further retries).  
   - The final `ClientResponse` is returned to the caller.  

Key internal state updates during the flow:
- `self._challenge` – latest parsed challenge parameters.  
- `self._protection_space` – list of base URIs derived from the `domain` directive or the origin.  
- `self._last_nonce_bytes` & `self._nonce_count` – ensure correct `nc` handling across retries.  

---

## 5. Usage Examples

> **Note:** The examples use only symbols that are actually defined in the source file.

```python
import aiohttp
from aiohttp.client_middleware_digest_auth import DigestAuthMiddleware

# 1️⃣ Create the middleware with your credentials.
digest_mw = DigestAuthMiddleware(login="myuser", password="s3cr3t", preemptive=True)

# 2️⃣ Attach the middleware to a ClientSession.
async with aiohttp.ClientSession(middlewares=[digest_mw]) as session:
    # Regular request – the middleware will handle the 401 challenge automatically.
    async with session.get("https://httpbin.org/digest-auth/auth/myuser/s3cr3t") as resp:
        print(resp.status)          # 200 when authentication succeeds
        data = await resp.json()
        print(data)
```

### Pre‑emptive mode disabled
If you want to avoid sending the `Authorization` header until the server issues a challenge:

```python
digest_mw = DigestAuthMiddleware("user", "pwd", preemptive=False)
# The first request will be unauthenticated; the middleware will retry once a challenge arrives.
```

### Using `auth-int` QoP
When the server demands `qop="auth-int"` the middleware automatically hashes the request payload:

```python
payload = aiohttp.payload.BytesPayload(b'{"key":"value"}')

async with aiohttp.ClientSession(middlewares=[digest_mw]) as session:
    async with session.post("https://example.com/secure", data=payload) as resp:
        ...
```

No additional code is required – the middleware inspects the challenge’s `qop` and computes the appropriate digest.

---

## 6. Notes for Developers

| Area | Important points / Gotchas |
|------|----------------------------|
| **Statefulness** | `DigestAuthMiddleware` holds mutable state (`_challenge`, nonce counters, protection space). It **must not** be shared across unrelated sessions unless they share the same authentication realm. |
| **Thread / Concurrency** | aiohttp runs the middleware inside the event loop; internal state modifications are therefore safe as long as a single middleware instance is used per `ClientSession`. |
| **Algorithm handling** | The algorithm name is taken verbatim from the challenge for the `algorithm=` field in the header, but it is upper‑cased for lookup in `DigestFunctions`. Unsupported algorithms raise `ClientError` with a helpful list. |
| **Session‑based algorithms** (`*-SESS`) | After computing the initial `HA1`, the code re‑hashes `HA1:nonce:cnonce`. This complies with RFC 7616. |
| **QoP `auth-int`** | The body is read **once** via `await body.as_bytes()` (for `Payload`). If the body is a plain `bytes` literal, it is used directly. Ensure that the payload can be re‑sent; otherwise the retry may fail. |
| **Nonce count (`nc`)** | The nonce count is reset when a new `nonce` value appears (as required for replay protection). It is formatted as an eight‑digit hexadecimal string. |
| **Client nonce (`cnonce`)** | Constructed from a combination of the nonce count, server nonce, current time and 8 random bytes, then truncated to 16 hex characters. |
| **Header parsing** | `_HEADER_PAIRS_PATTERN` follows the RFC syntax, handling escaped quotes (`\"`). Malformed headers silently result in an empty dict, leading the middleware to skip authentication. |
| **Protection space calculation** | If the challenge supplies a `domain` directive, each token is interpreted as a URI. Relative paths starting with `/` are resolved relative to the response origin. Otherwise the entire origin is used. |
| **Pre‑emptive authentication** | When `preemptive=True` (default) and the middleware already knows a challenge that matches the request URL, it sends the `Authorization` header on the **first** request, potentially saving a round‑trip. |
| **Error handling** | Errors such as missing `realm`/`nonce`, empty nonce, or unsupported algorithm raise `ClientError`. These propagate to the caller and abort further retries. |
| **Extensibility** | Adding support for newer hash algorithms simply requires updating `DigestFunctions` and `SUPPORTED_ALGORITHMS`. The rest of the code relies on the generic `hash_fn` interface. |
| **Testing** | Unit tests should mock `ClientResponse` objects with various `WWW-Authenticate` header shapes (quoted, unquoted, multiple qop values, missing fields) to verify parsing, challenge handling, and header generation. |
| **Security** | The code respects RFC recommendations (e.g., never sends a blank `nonce`, always includes `nc` and `cnonce` when QoP is present). Ensure that logs do **not** inadvertently expose `Authorization` headers or raw passwords. |

--- 

*End of documentation.*