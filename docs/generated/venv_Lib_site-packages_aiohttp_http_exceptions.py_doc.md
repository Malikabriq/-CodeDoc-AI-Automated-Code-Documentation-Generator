# ðŸ“„ aiohttp.http_exceptions â€“ Lowâ€‘level HTTPâ€‘related Exceptions  

*File*: `venv\Lib\site-packages\aiohttp\http_exceptions.py`

---

## 1. Module Purpose  

| **What** | **Why** |
|----------|----------|
|Defines a hierarchy of concrete exception classes that represent HTTP protocol errors. |During parsing of request/response lines, headers, payloads, etc., the aiohttp core needs a uniform way to abort processing and signal *why* the HTTP message is malformed. These exceptions carry the proper HTTP status code, a humanâ€‘readable message, and optional response headers, allowing the server/client to formulate a correct HTTP response (or raise a clientâ€‘side error). |
|Provides `HttpProcessingError`, a lightweight base class that mimics an HTTP response (code, message, headers).|`HttpProcessingError` is used by the rest of aiohttp as a generic â€œsomething went wrong while processing HTTPâ€, while concrete subclasses encode specific protocol violations (e.g., bad request line, oversized header line, invalid charset).|

---

## 2. Key Components  

### 2.1 `HttpProcessingError` (base class)

| Aspect | Description |
|--------|-------------|
|**Purpose**|Base exception for all lowâ€‘level HTTP errors. Holds a status **code**, a **message**, and optional **headers** that should be sent back to the peer.|
|**Signature**|```python\nclass HttpProcessingError(Exception):\n    def __init__(self, *, code: Optional[int] = None, message: str = \"\", headers: Optional[_CIMultiDict] = None) -> None\n```|
|**Parameters**|* `code` â€“ Optional integer HTTP status code (default `0`). If supplied, overrides the class attribute `code`. <br>* `message` â€“ Humanâ€‘readable description (default empty). <br>* `headers` â€“ Optional `_CIMultiDict` (caseâ€‘insensitive multiâ€‘dictionary) of response headers.|
|**Attributes**|* `code` (int) â€“ HTTP status code. <br>* `message` (str) â€“ Error description. <br>* `headers` (`_CIMultiDict | None`).|
|**Public API**|* `__str__` â€“ Returns a formatted multiâ€‘line string: `"<code>, message:\n  <indented message>"`. <br>* `__repr__` â€“ Debug representation: `"<HttpProcessingError: 400, message='Bad Request'>"`.|
|**Internal Logic**|If `code` is supplied, the instance attribute `self.code` is overwritten; otherwise the classâ€‘level default remains. The constructor simply stores the arguments; no sideâ€‘effects.|

---

### 2.2 `BadHttpMessage`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`HttpProcessingError` |
|**Purpose**|Represents any *clientâ€‘fault* HTTP request/response that should be answered with **400 Bad Request** (or a custom 4xx code).|
|**Defaults**|`code = 400`, `message = "Bad Request"`|
|**Signature**|```python\ndef __init__(self, message: str, *, headers: Optional[_CIMultiDict] = None) -> None\n```|
|**Behaviour**|Calls `super().__init__(message=message, headers=headers)` while preserving the default code (`400`). It also forces `self.args` to a singleâ€‘element tuple containing the raw `message` (for compatibility with legacy exception handling).|
|**Public API**|Same as `HttpProcessingError` plus the explicit `message` argument.|

---

### 2.3 `HttpBadRequest`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`BadHttpMessage` |
|**Purpose**|A thin alias for a 400 error with the default â€œBad Requestâ€ message. No additional logic â€“ useful for semantic clarity when raising a generic badâ€‘request error.|
|**Defaults**|`code = 400`, `message = "Bad Request"`|

---

### 2.4 `PayloadEncodingError`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`BadHttpMessage` |
|**Purpose**|Base class for all errors that arise while decoding the **payload** (body) of an HTTP message.|
|**Defaults**|inherits `code = 400` and the generic â€œBad Requestâ€ message unless overridden by subclasses.|

---

#### 2.4.1 `ContentEncodingError`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`PayloadEncodingError` |
|**Purpose**|Signals a failure to decode the body according to the declared **Contentâ€‘Encoding** (e.g., gzip, deflate).|
|**Message**|Inherited â€“ the caller typically supplies a custom message via the constructor of `BadHttpMessage`.|

#### 2.4.2 `TransferEncodingError`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`PayloadEncodingError` |
|**Purpose**|Indicates an invalid **Transferâ€‘Encoding** header (e.g., unsupported chunked encoding).|

#### 2.4.3 `ContentLengthError`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`PayloadEncodingError` |
|**Purpose**|Raised when the received body is **shorter** than the length declared by the `Contentâ€‘Length` header. The exception signals that the request is incomplete or malformed.|

---

### 2.5 `LineTooLong`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`BadHttpMessage` |
|**Purpose**|Raised when a single line (e.g., startâ€‘line or header line) exceeds a configured size limit.|
|**Signature**|```python\ndef __init__(self, line: str, limit: str = \"Unknown\", actual_size: str = \"Unknown\") -> None\n```|
|**Behaviour**|Constructs a helpful message: `"Got more than {limit} bytes ({actual_size}) when reading {line}."` and stores `(line, limit, actual_size)` in `self.args`.|
|**Attributes**|`args` tuple contains the raw values for downstream inspection.|

---

### 2.6 `InvalidHeader`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`BadHttpMessage` |
|**Purpose**|Indicates that a raw HTTP header line cannot be parsed (e.g., missing colon, nonâ€‘ASCII characters).|
|**Signature**|```python\ndef __init__(self, hdr: Union[bytes, str]) -> None\n```|
|**Logic**|If `hdr` is a `bytes` object, it is decoded using `errors=\"backslashreplace\"` to avoid UnicodeDecodeError. The displayed message contains the **repr** of the original header, while the decoded string is stored in `self.hdr`.|
|**Attributes**|* `hdr` â€“ decoded header string (for logging). <br>* `args` â€“ tuple containing the original header object. |

---

### 2.7 `BadStatusLine`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`BadHttpMessage` |
|**Purpose**|Represents a malformed **status line** (the first line of an HTTP request/response).|
|**Signature**|```python\ndef __init__(self, line: str = \"\", error: Optional[str] = None) -> None\n```|
|**Behaviour**|If `line` is not a string, its `repr` is used. The final error message is either the supplied `error` or `"Bad status line {line!r}"`. Stores the raw line in `self.line` and pushes it into `self.args`.|
|**Attributes**|* `line` â€“ the original line (string). |

---

### 2.8 `BadHttpMethod`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`BadStatusLine` |
|**Purpose**|Specific variant of `BadStatusLine` for **invalid HTTP methods** (e.g., unknown verbs, malformed request line).|
|**Signature**|```python\ndef __init__(self, line: str = \"\", error: Optional[str] = None) -> None\n```|
|**Behaviour**|Calls `super().__init__(line, error or f\"Bad HTTP method in status line {line!r}\")`. No extra attributes beyond those inherited. |

---

### 2.9 `InvalidURLError`

| Aspect | Description |
|--------|-------------|
|**Inheritance**|`BadHttpMessage` |
|**Purpose**|Signals that the request target URI cannot be parsed or is otherwise illegal (e.g., malformed percentâ€‘encoding).|
|**Implementation**|Empty subclass â€“ the mere type is sufficient for callers to differentiate *invalid URI* from other badâ€‘request errors. |

---

## 3. Dependencies & Relationships  

### 3.1 Imports  

| Module | Reason for Import |
|--------|-------------------|
|`textwrap.indent`|Used in `HttpProcessingError.__str__` to prettyâ€‘print the error message with an indentation prefix.|
|`typing.Optional`, `typing.Union`|Type hints for optional arguments and union types (bytes or str).|
|`.typedefs._CIMultiDict`|Type alias for a caseâ€‘insensitive multidict used to store HTTP headers. The class is defined elsewhere in the aiohttp package (typically `aiohttp.typedefs`).|

### 3.2 Interaction with the Rest of aiohttp  

| **Direction** | **Component** | **Explanation** |
|---------------|----------------|-----------------|
| **Uses** | `aiohttp.typedefs._CIMultiDict` | To typeâ€‘annotate the optional `headers` argument, allowing callers to pass a mutable mapping of response headers. |
| **Used by** | `aiohttp.http_parser`, `aiohttp.web_protocol`, `aiohttp.client_proto`, etc. | These lowerâ€‘level modules raise the defined exceptions when they encounter malformed HTTP data while reading from sockets. |
| **Caught by** | `aiohttp.web.Response`, `aiohttp.web.Application.handle_error`, `aiohttp.client._request` | The framework catches `HttpProcessingError` (or subclasses) to translate them into HTTP responses (e.g., 400 Bad Request) or to surface them to the user code. |
| **Extensible** | User code (custom middleware, servers) | Users can subclass these errors to add more context while preserving the HTTPâ€‘centric semantics. |

### 3.3 Architectural Placement  

* **Layer**: *Protocol parsing / error handling* (below the highâ€‘level request/response abstractions).  
* **Responsibility**: Provide a **canonical** set of exception types that carry both *machineâ€‘readable* data (`code`, optional `headers`) and *humanâ€‘readable* messages. This enables a clear separation: parsing modules only raise; higher layers decide how to report.  

---

## 4. Workflow Description  

1. **Parsing begins** â€“ e.g., `aiohttp.http_parser.HttpResponseParser` reads data from a socket.  
2. **Encounter a malformed construct** (e.g., line too long, missing header colon).  
3. **Raise the appropriate exception**:  
   * `LineTooLong` for a sizeâ€‘limit violation.  
   * `InvalidHeader` when a header cannot be parsed.  
   * `BadStatusLine` / `BadHttpMethod` for request/response startâ€‘line issues.  
   * `PayloadEncodingError` subâ€‘classes for bodyâ€‘related problems.  
4. **Exception propagates up** the call stack to the protocol handler (`aiohttp.http_parser`, `aiohttp.web_protocol`).  
5. **Protocol handler catches** `HttpProcessingError` (or any subclass).  
   * Uses `exc.code` to set the HTTP status of the response.  
   * Copies `exc.headers` (if present) into the response header collection.  
   * Optionally logs `str(exc)` for debugging (the formatted message).  
6. **Response is sent** back to the client, or the error is reâ€‘raised to user code (clientâ€‘side).  

**Key characteristic:** the *exception itself* fully describes the HTTP error â€“ no additional parsing state is required after it is caught.

---

## 5. Usage Examples  

> **Note:** The examples below are inferred from the public API; they illustrate how a developer (or aiohttp core) would raise and handle these exceptions.

### 5.1 Raising a simple 400 Bad Request

```python
from aiohttp.http_exceptions import BadHttpMessage

def validate_request_method(method: str) -> None:
    if method not in {"GET", "POST", "PUT", "DELETE"}:
        raise BadHttpMessage(f"Unsupported HTTP method: {method!r}")
```

### 5.2 Raising a custom error with additional headers

```python
from aiohttp.http_exceptions import HttpProcessingError
from aiohttp.typedefs import CIMultiDict

def raise_rate_limit():
    headers = CIMultiDict({"Retry-After": "30"})
    raise HttpProcessingError(
        code=429,
        message="Too Many Requests â€“ try again later",
        headers=headers,
    )
```

### 5.3 Handling an exception in a middleware

```python
from aiohttp import web
from aiohttp.http_exceptions import HttpProcessingError

@web.middleware
async def http_error_middleware(request, handler):
    try:
        return await handler(request)
    except HttpProcessingError as exc:
        # Build an HTTP response from the exception data
        resp = web.Response(status=exc.code, text=exc.message)
        if exc.headers:
            resp.headers.extend(exc.headers)
        return resp
```

### 5.4 Clientâ€‘side usage â€“ catching a bad response while streaming

```python
from aiohttp import ClientSession
from aiohttp.http_exceptions import ContentLengthError

async with ClientSession() as sess:
    async with sess.get("http://example.com/large") as resp:
        try:
            data = await resp.read()
        except ContentLengthError:
            print("Got less data than declared by Contentâ€‘Length")
```

---

## 6. Notes for Developers  

| Category | Guidance / Pitfalls |
|----------|---------------------|
|**Exception hierarchy**|All custom HTTP errors inherit from `HttpProcessingError`. When adding a new error type, subclass the most specific existing class (e.g., `PayloadEncodingError` for bodyâ€‘related issues) to preserve the semantic mapping to HTTP status codes.|
|**Mutable defaults**|`headers` defaults to `None`. Never use a mutable default object (e.g., `{}`) at class level, as it would be shared across instances.|
|**`args` manipulation**|Many subclasses explicitly rewrite `self.args` to hold raw data (e.g., `LineTooLong`). This mimics the legacy behaviour of builtâ€‘in exceptions where `args` is used for positional information. When extending the hierarchy, keep this pattern if downstream code inspects `exc.args`.|
|**Message formatting**|`HttpProcessingError.__str__` indents the message for readability. Ensure that custom messages do not contain leading whitespace unless intended, as the indent will be added on top.|
|**Header type**|`_CIMultiDict` is a caseâ€‘insensitive mapping; do not pass a plain `dict` if the caller expects headerâ€‘aware behavior (e.g., duplicate header values).|
|**Encoding concerns**|`InvalidHeader` decodes raw bytes using `backslashreplace`. This guarantees that *any* byte sequence can be turned into a printable string without raising another exception.|
|**Compatibility**|Older aiohttp versions may rely on the exact names of these exceptions (e.g., `HttpBadRequest`). Keep the public names unchanged to avoid breaking downstream libraries.|
|**Testing**|When unitâ€‘testing parsers, assert that the correct subclass is raised and that `exc.code`, `exc.message`, and `exc.headers` match the expectation.|
|**Performance**|Exceptions are intended for *exceptional* situations (malformed client data). Raising them frequently in normal traffic can be costly; ensure parsers enforce size limits early to avoid unnecessary exception creation.|

--- 

*End of documentation for `aiohttp.http_exceptions`.*