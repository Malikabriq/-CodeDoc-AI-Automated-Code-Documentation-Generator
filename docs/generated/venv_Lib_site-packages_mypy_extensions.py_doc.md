# `mypy_extensions.py` – Developer Documentation  

*Location:* `venv\Lib\site-packages\mypy_extensions.py`  

---  

## 1. Module Purpose  

| Aspect | Description |
|--------|-------------|
| **Responsibility** | Supplies *experimental* typing extensions that are understood by the **mypy** static type‑checker but are not part of the official `typing` module (or were added there later). |
| **Why it exists** | - Before the standard library offered `TypedDict`, `NoReturn`, and a few other constructs, projects that wanted static type information had to rely on an external helper module that mypy could recognize.  <br>- The module also contains assorted helpers (`Arg`, `VarArg`, `FlexibleAlias`, native‑int shims) used by mypy's own test suite and by code compiled with **mypy‑c**. <br>- It deliberately provides *no runtime enforcement*; everything is a thin wrapper that behaves like normal Python objects, while type checkers treat the objects specially. |

> **Note** – The module is **deprecated** in favor of `typing.TypedDict`, `typing.NoReturn`, and the `typing_extensions` package. Most symbols emit a `DeprecationWarning` when used.  

---

## 2. Key Components  

### 2.1 Helper Functions (internal)

| Name | Signature | Description |
|------|-----------|-------------|
| `_check_fails` | `(_check_fails(cls: type, other: Any) -> bool)` | Used as `__instancecheck__` / `__subclasscheck__` for `TypedDict`. It always returns `False` and raises a `TypeError` if the check is attempted from user code (except from modules `abc`, `functools`, or `typing`). Prevents `isinstance`/`issubclass` on a `TypedDict`. |
| `_dict_new` | `(_dict_new(cls: type, *args, **kwargs) -> dict)` | Simple proxy that calls the built‑in `dict` constructor. Used for normal dictionaries and for concrete subclasses of `TypedDict`. |
| `_typeddict_new` | `(_typeddict_new(cls: type, _typename: str, _fields: Optional[Mapping[str, Any]] = None, **kwargs) -> dict)` | Implements the *functional* syntax `TypedDict('Name', {'a': int}, total=False)`. It builds a namespace with `__annotations__` and `__total__`, then creates a new class via `_TypedDictMeta`. Returns a plain `dict` instance (the class itself is a subclass of `dict`). |
| `_warn_deprecation` | `(_warn_deprecation(name: str, module_globals: Dict[str, Any]) -> Any)` | Centralised routine used by `__getattr__` to lazily expose deprecated symbols (`NoReturn`, etc.). Emits a `DeprecationWarning` and injects the deprecated object into the module globals. |
| `__getattr__` | `(__getattr__(name: str) -> Any)` | Python 3.7+ module‑level fallback for attribute access. When an attribute is missing, it forwards to `_warn_deprecation`. This enables lazy deprecation of symbols without polluting the module namespace upfront. |

### 2.2 Core Metaclass – `_TypedDictMeta`

```python
class _TypedDictMeta(type):
    def __new__(cls, name, bases, ns, total=True, _from_functional_call=False):
        ...
    __instancecheck__ = __subclasscheck__ = _check_fails
```

| Aspect | Details |
|--------|---------|
| **Purpose** | Creates *TypedDict* classes that behave like normal dictionaries at runtime but carry type information in `__annotations__` and the `__total__` flag for static analysis. |
| **Parameters** | * `name` – class name (e.g., `'Point2D'`. <br>* `bases` – base classes (normally empty, but can inherit from another TypedDict). <br>* `ns` – class namespace dict (may contain `__annotations__`). <br>* `total` – boolean indicating whether all fields are required (default `True`). <br>* `_from_functional_call` – internal flag used to choose the correct warning stack level. |
| **Key Logic** | 1. **Deprecation warning** – when `TypedDict` itself is created, warns that the symbol is deprecated. <br>2. **Constructor selection** – `__new__` is replaced with `_typeddict_new` for the base `TypedDict` class, otherwise with `_dict_new`. <br>3. **Base class** – the new type always inherits from `dict`. <br>4. **Annotations processing** – each annotation value is validated with the private typing helper `_type_check`; annotations from base TypedDicts are merged. <br>5. **`__total__` handling** – stored on the class unless already present. |
| **Public API** | The resulting class objects (including the base `TypedDict`) are public; they expose the normal dictionary API and have the additional attributes `__annotations__` and `__total__`. |

### 2.3 Public Symbol – `TypedDict`

```python
TypedDict = _TypedDictMeta('TypedDict', (dict,), {})
TypedDict.__module__ = __name__
TypedDict.__doc__ = """..."""
```

| What it is | A *class factory* (metaclass‑based) that can be used in three equivalent ways: |
|------------|------------------------------------------------|
| **Functional syntax** | `Point = TypedDict('Point', {'x': int, 'y': int})` |
| **Keyword‑argument functional syntax** | `Point = TypedDict('Point', x=int, y=int, total=False)` |
| **Subclass syntax** (Python 3.6+) | ```python\nclass Point(TypedDict):\n    x: int\n    y: int\n``` |
| **Runtime behaviour** | Instances are ordinary `dict`s; no runtime type checking occurs. |
| **Static‑type effect** | mypy treats the class as a *typed mapping* where keys are known and values conform to the declared types, respecting the `total` flag. |

### 2.4 Argument‑Constructor Helpers  

These functions exist solely so that *type signatures* can be written concisely when constructing `Callable` types. They simply return the supplied type.

| Function | Signature | Meaning |
|----------|-----------|---------|
| `Arg` | `Arg(type: Any = Any, name: Optional[str] = None) -> Any` | Positional argument. |
| `DefaultArg` | `DefaultArg(type: Any = Any, name: Optional[str] = None) -> Any` | Positional argument with a default value. |
| `NamedArg` | `NamedArg(type: Any = Any, name: Optional[str] = None) -> Any` | Keyword‑only argument. |
| `DefaultNamedArg` | `DefaultNamedArg(type: Any = Any, name: Optional[str] = None) -> Any` | Keyword‑only argument with a default value. |
| `VarArg` | `VarArg(type: Any = Any) -> Any` | `*args`‑style variadic positional argument. |
| `KwArg` | `KwArg(type: Any = Any) -> Any` | `**kwargs`‑style variadic keyword argument. |

> **Runtime** – All functions are no‑ops; they simply return the `type` argument unchanged.

### 2.5 Deprecated `NoReturn` Placeholder  

```python
class _DEPRECATED_NoReturn: pass
```

*Exposed via `__getattr__` as `NoReturn`. When accessed, a deprecation warning is emitted, advising the caller to use `typing.NoReturn` instead.*

### 2.6 Miscellaneous Utilities  

| Symbol | Description |
|--------|-------------|
| `trait` | Identity decorator – returns the class unchanged. Used by mypyc to mark “traits”. |
| `mypyc_attr(*attrs, **kwattrs)` | Returns a decorator that leaves the object untouched. Intended for annotating **mypy‑c**‑specific attributes. |
| `FlexibleAlias` | **Dynamic alias** – `FlexibleAlias[T]` evaluates to the *last* argument supplied (`T`). Implemented via two helper classes (`_FlexibleAliasCls` and `_FlexibleAliasClsApplied`). Useful for generic type tricks in mypy. |
| `_NativeIntMeta` | Metaclass that makes its subclasses (`i64`, `i32`, `i16`, `u8`) behave like `int` for `isinstance` checks. |
| `i64`, `i32`, `i16`, `u8` | Classes representing native fixed‑width integers for **mypy‑c** compiled code. At runtime they behave exactly like the built‑in `int` (including the `int(x, base)` constructor signature). Documentation strings are generated dynamically. |

---

## 3. Dependencies & Relationships  

### 3.1 Imports  

| Import | Origin | Reason for Use |
|--------|--------|----------------|
| `Any, Dict` | `typing` | Type hints for internal functions (`_warn_deprecation`, `__getattr__`). |
| `sys` | Standard library | Access to stack frames (`sys._getframe`) for module name detection and to enforce the “no isinstance checks” rule. |
| `_type_check` | `typing` (private) | Validates that each annotation supplied to a `TypedDict` is an actual type (mypy‑specific helper). Marked `# type: ignore` because the name is private. |
| `warnings` (imported lazily) | Standard library | Emit deprecation warnings for `TypedDict` and other deprecated symbols. |
| `module globals` (via `globals()`) | Built‑in | Used by `__getattr__` to inject deprecated symbols lazily. |

### 3.2 Interaction with the Rest of the Project  

| Direction | Description |
|-----------|-------------|
| **Consumes** | - `typing._type_check` (internal). <br>- `sys` for frame introspection. |
| **Provides** | - Public symbols (`TypedDict`, `Arg`… etc.) that user code or mypy plugins import as `from mypy_extensions import TypedDict`. <br>- Backward‑compatible shims for older mypy versions and for code compiled with **mypy‑c** (native integer types, `FlexibleAlias`). |
| **Potential Consumers** | - User applications that still import `TypedDict` from this module (pre‑Python 3.8). <br>- Test suites or internal mypy modules that rely on the argument‑constructor helpers. <br>- Code compiled with **mypy‑c** that uses `i64`, `u8`, … for performance annotations. |
| **Placement in Architecture** | This module lives **outside** the core mypy type‑checker but inside the same distribution (`site‑packages`). It is an *optional compatibility layer*; the rest of the project (runtime code, mypyc) can import it without pulling in heavy mypy internals. |

---

## 4. Workflow Description  

### 4.1 Creating a `TypedDict`  

1. **Functional call** – `TypedDict('Name', {'a': int, 'b': str}, total=False)`  
   - Python evaluates the call → `TypedDict.__call__` resolves to the metaclass’s `__new__`.  
   - Inside `_typeddict_new` the supplied mapping (`{'a': int, …}`) is stored as `__annotations__`; `total` flag is recorded.  
   - `_TypedDictMeta` constructs a new class that inherits from `dict` and returns it.  

2. **Keyword‑argument functional call** – `TypedDict('Name', a=int, b=str)`  
   - Same pathway, but `kwargs` are interpreted as the field mapping.  

3. **Subclass syntax** – `class Name(TypedDict): a: int; b: str` (Python ≥ 3.6)  
   - The class body creates a namespace where `__annotations__` already contain the field types.  
   - The metaclass’s `__new__` receives that namespace, merges any base annotations, validates them, and installs `__new__` = `_dict_new`.  

### 4.2 Runtime Instantiation  

- Instantiating a concrete TypedDict subclass (e.g., `Name(x=1, y='a')`) invokes `_dict_new` (inherited from `dict`), therefore returns a plain `dict` object.  
- No runtime validation of key presence or value types occurs; static checking is delegated to mypy.  

### 4.3 Deprecation Flow  

- Importing `TypedDict` from this module triggers a deprecation warning **once** (when the base `TypedDict` class is constructed).  
- Accessing deprecated symbols such as `NoReturn` invokes the module‑level `__getattr__`, which calls `_warn_deprecation`. This injects the real implementation into `globals()` and emits a warning.  

### 4.4 Native Integer Shims (`i64`, `i32`, `i16`, `u8`)  

- Each class uses `_NativeIntMeta` so `isinstance(x, i64)` is `True` exactly when `isinstance(x, int)`.  
- Their `__new__` mirrors the built‑in `int` constructor, supporting optional `base` argument via a sentinel to differentiate the two‑argument form.  

---

## 5. Usage Examples  

### 5.1 Defining and Using a `TypedDict`

```python
from mypy_extensions import TypedDict

# Functional syntax
User = TypedDict('User', {'id': int, 'name': str, 'email': str}, total=True)

# Keyword‑argument functional syntax (equivalent)
User2 = TypedDict('User2', id=int, name=str, email=str, total=False)

# Subclass syntax (Python 3.6+)
class Product(TypedDict):
    sku: str
    price: float
    in_stock: bool

# Runtime usage – behaves like a normal dict
u: User = {'id': 42, 'name': 'Ada', 'email': 'ada@example.com'}
assert u['name'] == 'Ada'

# The type information is stored in __annotations__
assert User.__annotations__ == {'id': int, 'name': str, 'email': str}
```

### 5.2 Argument‑Constructor Helpers (for Callable signatures)

```python
from mypy_extensions import Arg, VarArg, KwArg

# Example type annotation (static only)
def concat(*parts: VarArg(str)) -> str: ...
def foo(a: Arg(int), b: DefaultArg(str), *rest: VarArg(float), **kw: KwArg(bool)) -> None: ...
```

### 5.3 Using Native Integer Shims (mypy‑c context)

```python
from mypy_extensions import i64, u8

def add_ints(a: i64, b: i64) -> i64:
    return a + b

assert isinstance(i64(10), int)   # True
assert isinstance(i64(10), i64)   # True
```

### 5.4 Accessing a Deprecated Symbol

```python
from mypy_extensions import NoReturn  # triggers DeprecationWarning
```

---

## 6. Notes for Developers  

| Area | Important Points |
|------|-------------------|
| **Runtime vs. Static** | The module **does not enforce** any typing constraints at runtime. All checks are performed by the mypy static analyzer. |
| **Deprecation Path** | New code should import `TypedDict` and `NoReturn` from `typing` (or `typing_extensions` for older Python versions). The deprecation warnings are intentionally emitted **once per interpreter session** to avoid noisy logs. |
| **`__instancecheck__` Override** | By setting both `__instancecheck__` and `__subclasscheck__` to `_check_fails`, the class deliberately *fails* any `isinstance` or `issubclass` test from user code, preserving the “structural typing only” contract. |
| **Frame Inspection** | `_check_fails` uses `sys._getframe(1).f_globals['__name__']` to allow only internal modules (`abc`, `functools`, `typing`) to perform the check without raising. This is a defensive measure rather than a security feature. |
| **`_type_check` Private API** | The import `from typing import _type_check` is guarded with `# type: ignore` because the name is private and may change. It is only used to validate that each annotation supplied to a `TypedDict` is a *type* object, mirroring the behaviour of the official `typing` implementation. |
| **Picklability** | The generated namespace sets `__module__` based on the caller’s frame, ensuring that classes created via the functional syntax can be pickled/unpickled correctly. |
| **FlexibleAlias Mechanics** | `FlexibleAlias[T]` resolves to `T`. This is used by mypy’s internal generic handling (e.g., to make `typevar` aliases that are later replaced). The implementation deliberately discards all but the last argument, so `FlexibleAlias[int, str]` yields `str`. |
| **Native Integer Classes** | They exist solely for **mypy‑c** compiled code that can map them onto low‑level C integer types. At pure‑Python runtime they are indistinguishable from `int`. |
| **Thread Safety** | All module‑level state mutations (`module_globals[name] = val` in `_warn_deprecation`) happen once per missing attribute and are therefore effectively thread‑safe under the Global Interpreter Lock (GIL). |
| **Testing** | The module is heavily exercised by mypy’s own test suite. When modifying any part (especially the metaclass logic), ensure that both *functional* and *subclass* TypedDict definitions continue to produce the same `__annotations__` structure. |
| **Python Version Compatibility** | - The subclass syntax (`class X(TypedDict): …`) requires Python ≥ 3.6 (due to PEP 526 variable annotations). <br>- All other features work back to Python 3.2, matching the original mypy‑extensions release. |

---  

*End of documentation.*