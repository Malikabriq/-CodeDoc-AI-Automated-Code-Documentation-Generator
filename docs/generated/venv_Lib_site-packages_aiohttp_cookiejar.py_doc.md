# aiohttp.cookiejar  

## 1. Module Purpose  

**What this file is responsible for**  
- Implements a **RFC 6265‑compliant cookie jar** used by the aiohttp client session.  
- Provides storage, expiration handling, persistence (save/load), and retrieval of cookies to be sent with outgoing HTTP requests.  
- Offers a *dummy* implementation (`DummyCookieJar`) for use‑cases where cookie handling is deliberately disabled.

**Why it exists in the project**  
- aiohttp’s `ClientSession` needs a pluggable component that can **track `Set‑Cookie` headers** received from responses, keep them according to domain/path/security rules, expire them automatically, and produce the appropriate **`Cookie` header** for subsequent requests.  
- Centralising this logic in a dedicated module isolates the complex RFC‑6265 rules from the rest of the HTTP client code, makes the behaviour testable, and allows the session to switch to a no‑op version (`DummyCookieJar`) when cookies are not required (e.g., for performance‑critical scripts).

---

## 2. Key Components  

### 2.1 Public Constants  

| Name | Description |
|------|-------------|
| `COOKIE_JAR` (exposed via `__all__`) | Exported names: `CookieJar`, `DummyCookieJar`. |
| `_FORMAT_PATH` , `_FORMAT_DOMAIN_REVERSED` | Cached `str.format` callables used for fast construction of path and domain strings when iterating over possible matches. |
| `_MIN_SCHEDULED_COOKIE_EXPIRATION` | Threshold that triggers a cleanup of the expiration heap to avoid it growing unchecked. |
| `_SIMPLE_COOKIE` | A shared `SimpleCookie` instance used for value encoding when building morsels. |
| `MAX_TIME`, `SUB_MAX_TIME` | Upper bound for cookie expiration timestamps (capped to the maximum representable POSIX time on the current platform). |

---

### 2.2 `CookieJar` – main implementation  

```python
class CookieJar(AbstractCookieJar):
```

#### Purpose  
- Stores cookies, enforces domain/path/security restrictions, manages expirations, and supplies filtered cookies for a request.

#### Important attributes (initialised in `__init__`)  

| Attribute | Type | Meaning |
|-----------|------|----------|
| `_cookies` | `DefaultDict[Tuple[str,str], SimpleCookie]` | Mapping **(domain, path) → cookie container**. |
| `_morsel_cache` | `DefaultDict[Tuple[str,str], Dict[str, Morsel]]` | Cache of *ready‑to‑send* morsels for each (domain,path) pair to avoid rebuilding on every request. |
| `_host_only_cookies` | `Set[Tuple[str,str]]` | Holds the **host‑only** flag pairs `(domain, name)`. |
| `_unsafe` | `bool` | When `True` accept cookies from IP addresses; otherwise they are ignored. |
| `_quote_cookie` | `bool` | Controls whether cookie values are quoted when sent. |
| `_treat_as_secure_origin` | `List[URL]` | Origins that should be treated as secure even when the request scheme is not `https`/`wss`. |
| `_expire_heap` | `List[Tuple[float, Tuple[str,str,str]]]` | Min‑heap of `(expiration_timestamp, (domain, path, name))` for fast expiry checks. |
| `_expirations` | `Dict[Tuple[str,str,str], float]` | Direct lookup of the scheduled expiration timestamp for a cookie. |

#### Public API  

| Method | Signature | Description |
|--------|-----------|-------------|
| `quote_cookie` | `@property -> bool` | Returns the current quoting behaviour. |
| `save` | `save(file_path: PathLike) -> None` | Serialises the cookie storage to a file using `pickle`. |
| `load` | `load(file_path: PathLike) -> None` | Restores previously saved cookies from a file. |
| `clear` | `clear(predicate: Optional[ClearCookiePredicate] = None) -> None` | Removes **all** cookies (or a subset matching a predicate). |
| `clear_domain` | `clear_domain(domain: str) -> None` | Removes every cookie belonging to the supplied domain. |
| `__iter__` | `__iter__() -> Iterator[Morsel]` | Iterates over **all non‑expired** morsels, performing expiration first. |
| `__len__` | `__len__() -> int` | Number of stored (non‑expired) cookies without triggering expiration. |
| `update_cookies` | `update_cookies(cookies: LooseCookies, response_url: URL = URL()) -> None` | Incorporates new cookies from a `Set‑Cookie` header or a mapping, applying RFC‑6265 rules. |
| `filter_cookies` | `filter_cookies(request_url: URL = URL()) -> BaseCookie` | Returns a cookie collection that should be attached to an outgoing request URL. |
| `_do_expiration` | `_do_expiration() -> None` (private) | Removes any cookies whose expiration timestamp has passed. |
| `_expire_cookie` | `_expire_cookie(when: float, domain: str, path: str, name: str) -> None` | Schedules a cookie for future removal. |
| `_build_morsel` | `_build_morsel(cookie: Morsel) -> Morsel` | Creates a **sending‑ready** morsel, respecting `quote_cookie`. |
| `_is_domain_match` | `@staticmethod _is_domain_match(domain: str, hostname: str) -> bool` | Implements RFC‑6265 domain‑matching logic. |
| `_parse_date` | `@classmethod _parse_date(date_str: str) -> Optional[int]` | Parses a cookie `Expires` attribute into a POSIX timestamp. |

#### Internal Logic Overview  

1. **Construction**  
   - Normalises `treat_as_secure_origin` into a list of `yarl.URL` origins.  
   - Prepares the internal dictionaries/sets and the expiration heap.

2. **Adding Cookies (`update_cookies`)**  
   - Rejects cookies from IPs unless `_unsafe` is `True`.  
   - Normalises each entry to a `Morsel`.  
   - Handles missing `domain` (host‑only) and missing `path` (default‑path algorithm).  
   - Strips leading dots on domains, validates domain matching with the response host.  
   - Computes expiration from `Max-Age` or `Expires` (delegating to `_parse_date`).  
   - Stores the cookie under `(domain, path)` and updates the cache/expiration structures.  
   - Calls `_do_expiration` to purge any already‑expired items.

3. **Expiration Management**  
   - `_expire_cookie` pushes a tuple onto `_expire_heap`; duplicates are ignored.  
   - `_do_expiration` repeatedly pops heap entries whose timestamp ≤ `time.time()`.  
   - If the heap grows too large relative to the active expirations, a clean‑up pass rebuilds the heap based on the authoritative `_expirations` dict.

4. **Retrieving Cookies (`filter_cookies`)**  
   - Calls `_do_expiration` to guarantee only live cookies are considered.  
   - Resolves the request hostname and scheme (with optional “treat‑as‑secure” override).  
   - Generates a list of candidate **domains** (host and its parent domains) and **paths** (progressive prefixes).  
   - For each `(domain,path)` pair present in `_cookies`, applies RFC‑6265 rules:
     - Host‑only flag must match the exact request host.  
     - `Secure` attribute is honoured when the request is not secure.  
     - Path length checks avoid sending cookies whose path is longer than the request path.  
   - Uses a per‑pair morsel cache to avoid rebuilding the same sending morsel repeatedly.  

5. **Persistence (`save` / `load`)**  
   - Serialises the entire `_cookies` dict (including all morsels) with the highest pickle protocol.  
   - Deserialises and replaces the in‑memory `_cookies` dict.

---

### 2.3 `DummyCookieJar` – no‑op implementation  

```python
class DummyCookieJar(AbstractCookieJar):
```

#### Purpose  
- Provides a **lightweight placeholder** that satisfies the `AbstractCookieJar` API but never stores or returns any cookies.

#### Public API (all overridden to be no‑ops)  

| Method | Behaviour |
|--------|-----------|
| `__iter__` | Yields nothing. |
| `__len__` | Returns `0`. |
| `quote_cookie` (property) | Always `True`. |
| `clear`, `clear_domain`, `update_cookies` | No operation. |
| `filter_cookies` | Returns an empty `SimpleCookie`. |

#### When to use  
- Pass `cookie_jar=DummyCookieJar()` to `aiohttp.ClientSession` when applications do not need cookie handling and want to avoid the overhead of storing or processing cookies.

---

## 3. Dependencies & Relationships  

### Imports  

| Module | Reason |
|--------|--------|
| `asyncio`, `warnings`, `contextlib` | Event‑loop handling (base class) and runtime warnings. |
| `calendar`, `datetime`, `time` | Date parsing and timestamp calculations for expiration. |
| `heapq` | Efficient min‑heap for scheduled expirations. |
| `itertools` | Generation of domain and path candidate sequences. |
| `os`, `pathlib`, `pickle` | Persistence (saving/loading to/from files). |
| `re` | Regular expressions for robust date parsing (RFC 6265). |
| `collections`, `collections.abc` | Default dicts and typing of mappings. |
| `http.cookies` (`BaseCookie`, `Morsel`, `SimpleCookie`) | Core cookie representation used by the standard library. |
| `typing` (various) | Static type hints. |
| `yarl.URL` | URL parsing and manipulation (the URL type used throughout aiohttp). |
| `._cookie_helpers.preserve_morsel_with_coded_value` | Helper to keep a quoted value unchanged when quoting is required. |
| `.abc.AbstractCookieJar`, `.abc.ClearCookiePredicate` | Abstract base class defining the required interface. |
| `.helpers.is_ip_address` | Helper to detect IP literals for the unsafe‑mode rule. |
| `.typedefs` (`LooseCookies`, `PathLike`, `StrOrURL`) | Shared type aliases used across aiohttp. |

### Interaction with Other aiohttp Components  

| Component | Interaction |
|-----------|-------------|
| **`aiohttp.ClientSession`** | Instantiates a `CookieJar` (or `DummyCookieJar`) and delegates cookie handling: <br> • Calls `update_cookies` with response `Set‑Cookie` headers. <br> • Calls `filter_cookies` to build the `Cookie` header for each request. |
| **`aiohttp.helpers` / `aiohttp._cookie_helpers`** | Utilised for the `preserve_morsel_with_coded_value` function when quoting cookie values. |
| **`aiohttp.abc.AbstractCookieJar`** | Base class that defines the abstract interface (`clear`, `update_cookies`, `filter_cookies`, etc.). |
| **`yarl.URL`** | Provides the rich URL parsing needed for domain/path extraction, scheme checking, and origin handling. |

### Logical Dependents  

- Any component that requires cookie management (e.g., request/response middleware, authentication helpers) will rely on the `CookieJar` API.  
- Test suites that validate cookie behaviour import and instantiate `CookieJar`.  

### Architecture Placement  

- **Layer:** *client‑side HTTP utilities* – sits between the low‑level HTTP connector and the high‑level request/response objects.  
- **Responsibility:** Encapsulates stateful cookie logic; isolates RFC specifics from transport and protocol layers.

---

## 4. Workflow Description  

### 4.1 High‑level Flow  

1. **Session creation** → a `CookieJar` instance is constructed.  
2. **Response processing** → `ClientResponse` extracts `Set‑Cookie` headers and calls `jar.update_cookies(...)`.  
   - `update_cookies` normalises each cookie, decides its domain/path, schedules expiration, and stores it.  
3. **Request preparation** → before sending a request, `ClientSession` invokes `jar.filter_cookies(request_url)`.  
   - `filter_cookies` clears expired cookies, builds the set of applicable cookie domain/path pairs, respects `Secure` and host‑only flags, and returns a `BaseCookie` ready to be rendered in a `Cookie` header.  
4. **Periodic cleanup** → each call to `filter_cookies` or `update_cookies` triggers `_do_expiration`, which lazily removes stale cookies using the heap.  
5. **Optional persistence** → the user may call `jar.save(path)` to dump the current cookie store, and later `jar.load(path)` to restore it.  

### 4.2 Detailed Call Flow (example: handling a new `Set‑Cookie`)  

```
update_cookies(cookies, response_url)
 ├─ if not _unsafe and hostname is IP → return
 ├─ iterate over provided cookies
 │    ├─ ensure each entry is a Morsel
 │    ├─ normalise domain:
 │    │    • strip trailing dot
 │    │    • apply host‑only default when missing
 │    │    • strip leading dot
 │    ├─ reject if domain does not domain‑match the response host
 │    ├─ normalise path (default‑path algorithm)
 │    ├─ compute expiration:
 │    │    • Max‑Age → timestamp (capped to MAX_TIME)
 │    │    • else Expires → parsed via _parse_date()
 │    ├─ store cookie in self._cookies[(domain, path)]
 │    ├─ schedule expiration via _expire_cookie()
 └─ _do_expiration()   # clean up any already‑expired entries
```

### 4.3 Expiration Cleanup  

```
_do_expiration()
 ├─ if heap empty → return
 ├─ if heap size > threshold && heap size > 2*len(_expirations):
 │    └─ rebuild heap from _expirations (remove stale entries)
 ├─ while top of heap expires <= now:
 │    ├─ pop entry
 │    ├─ if its timestamp still matches _expirations → schedule deletion
 └─ _delete_cookies(list_of_expired_keys)
```

---

## 5. Usage Examples  

> The following snippets illustrate the intended public usage.  
> They rely only on the documented API; internal helpers are not shown.

### 5.1 Basic Cookie Jar with a Session  

```python
import asyncio
from aiohttp import ClientSession, CookieJar, URL

async def main():
    jar = CookieJar()
    async with ClientSession(cookie_jar=jar) as sess:
        # The first request may set cookies
        async with sess.get('https://example.com/') as resp:
            await resp.text()          # jar.update_cookies called internally

        # Subsequent request automatically receives stored cookies
        async with sess.get('https://example.com/profile') as resp:
            print(resp.request_info.headers['Cookie'])   # contains filtered cookies

    # Persist cookies for later runs
    jar.save('cookies.pkl')

# Run the coroutine
asyncio.run(main())
```

### 5.2 Using a Dummy Cookie Jar (no cookie handling)

```python
from aiohttp import ClientSession, DummyCookieJar

async with ClientSession(cookie_jar=DummyCookieJar()) as sess:
    async with sess.get('https://example.org/') as resp:
        # No Set-Cookie processing, no Cookie header sent
        ...
```

### 5.3 Manually Updating and Filtering Cookies  

```python
from aiohttp import CookieJar, URL
from http.cookies import SimpleCookie

jar = CookieJar()
# Manually add a cookie (similar to a Set-Cookie header)
raw = SimpleCookie()
raw['sessionid'] = 'abc123'
raw['sessionid']['path'] = '/'
raw['sessionid']['domain'] = 'example.com'
jar.update_cookies(raw, URL('https://example.com/'))

# Retrieve the cookies that would be sent to a specific URL
out = jar.filter_cookies(URL('https://example.com/dashboard'))
print(out.output())   # "sessionid=abc123"
```

---

## 6. Notes for Developers  

| Topic | Details |
|-------|---------|
| **Thread‑safety** | The jar is **not** thread‑safe. All operations are expected to run in the same event‑loop thread. |
| **Performance** | - Domain/path matching uses pre‑compiled format functions (`_FORMAT_PATH`, `_FORMAT_DOMAIN_REVERSED`). <br> - Expiration uses a min‑heap; clean‑up occurs only when the heap grows beyond `_MIN_SCHEDULED_COOKIE_EXPIRATION` **and** more than twice the number of active expirations, avoiding frequent heap rebuilds. |
| **IP address handling** | By default (`unsafe=False`) cookies coming from an IP address (including `localhost`) are ignored. Set `unsafe=True` if you need to accept them (e.g., during testing). |
| **Secure origin override** | `treat_as_secure_origin` lets callers mark HTTP origins as “secure” so that `Secure` cookies are still sent even when the request scheme is not `https`/`wss`. |
| **Cookie quoting** | `quote_cookie` controls quoting of cookie values. If `True` and the stored morsel’s `coded_value` already starts with a double‑quote, the original morsel is preserved via `preserve_morsel_with_coded_value`. |
| **Date parsing** | `_parse_date` is deliberately permissive: it extracts the first recognizable **day**, **month**, **year**, and **time** tokens from any string and attempts to build a UTC timestamp. Invalid or ambiguous dates result in the attribute being cleared. |
| **Maximum expiration** | The code caps timestamps to the highest POSIX time supported on the running platform (handles Windows limitation and 32‑bit overflow). |
| **Persistence format** | Cookies are pickled directly; any changes to the internal structure of `SimpleCookie`/`Morsel` could break compatibility with older pickles. Consider versioning or migration if the format changes in future releases. |
| **Extensibility** | Sub‑classing `AbstractCookieJar` is the official extension point. The dummy implementation shows the minimal contract required. |
| **Testing** | Unit tests should cover: <br> • Domain/path matching edge cases (sub‑domains, leading dot, IP hosts). <br> • Expiration handling, especially heap cleanup logic. <br> • Secure‑origin overrides. <br> • Interaction of `quote_cookie` flag with quoted values. |
| **Potential Pitfalls** | - **Domain leading dot**: stripped automatically; however, a trailing dot (`example.com.`) is treated as absent domain and discarded. <br> - **Path normalization**: a missing or malformed `Path` attribute falls back to the default‑path algorithm which may unexpectedly truncate the path. <br> - **Heap stale entries**: the heap can contain outdated timestamps if a cookie is re‑added with a different expiry; `self._expirations` protects against premature deletion. |

--- 

*End of documentation for `aiohttp.cookiejar`.*