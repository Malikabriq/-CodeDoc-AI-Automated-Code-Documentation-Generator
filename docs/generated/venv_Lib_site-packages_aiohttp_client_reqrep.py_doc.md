# aiohttp.client_reqrep – Client‑side HTTP request/response handling  

*File path:* `venv\Lib\site-packages\aiohttp\client_reqrep.py`

---

## 1. Module Purpose  

| What it does | Why it exists |
|--------------|---------------|
| Implements the low‑level **client request** (`ClientRequest`) and **client response** (`ClientResponse`) objects used by `aiohttp.ClientSession`. It translates a high‑level API call (`session.get()`, `session.post()`, …) into a fully‑compliant HTTP/1.1 request, streams the body, parses the status line, headers, cookies, and provides convenient helpers such as `.json()`, `.text()`, and `.raise_for_status()`. | Separates the *transport‑agnostic* HTTP logic from the higher‑level session/connector machinery, allowing a clear contract for: <br>• building request line & headers <br>• negotiating SSL/TLS, proxy, authentication <br>• handling chunked transfer, compression, and “100‑continue” <br>• exposing a rich response API while keeping streaming behaviour efficient. |

---

## 2. Key Components  

### 2.1 Helper Functions  

| Function | Purpose | Signature & Types | Return |
|----------|---------|-------------------|--------|
| `_gen_default_accept_encoding()` | Builds the default value for the **Accept‑Encoding** header based on optional Brotli/ZSTD support. | `() -> str` | e.g. `"gzip, deflate, br, zstd"` |
| `_is_expected_content_type(response_content_type, expected_content_type)` | Checks whether a received *Content‑Type* matches the type the caller expects (special handling for `application/json`). | `(str, str) -> bool` | `True`/`False` |
| `_warn_if_unclosed_payload(payload, stacklevel=2)` | Emits a `ResourceWarning` when a `payload.Payload` instance is not closed automatically (i.e. it holds file handles). | `(payload.Payload, int) -> None` | – |
| `_merge_ssl_params(ssl, verify_ssl, ssl_context, fingerprint)` | Normalises all deprecated SSL‑related arguments into a single *ssl* value (bool, `SSLContext`, or `Fingerprint`). Performs mutual‑exclusion checks and emits `DeprecationWarning`s. | `(... ) -> Union[SSLContext, bool, Fingerprint]` | Normalised ssl parameter |
| `_get_content_length(self)` *(method of `ClientRequest`)* | Reads the **Content‑Length** header, returns `int` or `None`, raises `ValueError` on malformed header. | `() -> Optional[int]` | Parsed length |
| `_response_eof(self)` *(method of `ClientResponse`)* | Callback invoked when the response payload reaches EOF – marks the response closed, cleans up the writer task, releases the connection. | `() -> None` | – |
| `_reset_writer(self, _: object = None)` *(both classes)* | Clears the internal reference to the writer task once it finishes. | `(object) -> None` | – |

### 2.2 Data Classes  

| Class | Description | Public API |
|-------|-------------|------------|
| **`ContentDisposition`** (`@attr.s(auto_attribs=True, frozen=True, slots=True)`) | Simple immutable holder for the result of parsing a `Content‑Disposition` header. | Attributes: `type: Optional[str]`, `parameters: MappingProxyType[str, str]`, `filename: Optional[str]` |
| **`RequestInfo`** (`NamedTuple` subclass) | Captures the request’s **url**, **method**, **headers**, and **real_url** (the URL after redirects). Used for error reporting and tracing. | `url`, `method`, `headers`, `real_url` (accessible as tuple fields). |
| **`Fingerprint`** | Represents a SHA‑256 fingerprint used to verify a TLS server certificate. Implements `check(transport)` which raises `ServerFingerprintMismatch` on mismatch. | `fingerprint` property, `check(transport)` |
| **`ConnectionKey`** (`NamedTuple`) | Hashable key identifying a connection in the connector’s pool (host, port, SSL flag, SSL context/fingerprint, proxy, proxy auth, proxy‑header hash). | All fields are tuple items; used internally by `Connector`. |

### 2.3 Core Public Classes  

#### 2.3.1 `ClientResponse`  

*Subclass of `HeadersMixin`.* Represents a single HTTP response and provides a streaming interface.

| Feature | Details |
|---------|---------|
| **Construction** | Created by `ClientRequest.send()`. The constructor receives method, URL, writer task, a *continue‑100* future, a timer, request info, traces, loop, and the originating `ClientSession`. |
| **Attributes (populated after `start()`)** | `version`, `status`, `reason`, `content` (`StreamReader`), `_headers` (CIMultiDictProxy), `_raw_headers`, `_history`, `_cookies`, `_raw_cookie_headers`, `_connection`, `_closed`, `_released`, `_in_context` |
| **`start(connection)`** | Reads the status line and headers from the underlying protocol (`HttpResponseParser`). Handles *1xx* informational responses, sets up EOF callbacks, and stores raw cookie headers. |
| **`read()`** | Reads the whole payload **once**, caches it in `_body`, returns `bytes`. Subsequent reads raise `ClientConnectionError`. |
| **`text(encoding=None, errors='strict')`** | Decodes the cached body using detected charset (via `get_encoding()`). |
| **`json(... )`** | Parses JSON (or any other MIME type supplied via `content_type`) after optionally checking the content‑type header. |
| **`get_encoding()`** | Determines the charset from `Content‑Type` or falls back to heuristics (`utf‑8` for JSON, a session‑provided resolver otherwise). |
| **Lifecycle** | `close()`, `release()`, `wait_for_close()`, context‑manager support (`__aenter__`, `__aexit__`). The response automatically releases its connection when the body is fully consumed or when exiting the async context. |
| **Convenience** | `ok` property, `raise_for_status()`, `.cookies` (parsed into `SimpleCookie`), `.content_disposition` (parsed into `ContentDisposition`), `.links` (parses HTTP `Link` header), `.history` (redirect chain). |
| **Tracing** | Calls any configured `Trace` objects when chunks are received (`send_response_chunk_received`). |

#### 2.3.2 `ClientRequest`  

Encapsulates all data needed to perform an HTTP request and to stream the request body.

| Feature | Details |
|---------|---------|
| **Construction arguments** | `method`, `url`, optional `params`, `headers`, `cookies`, `auth`, `compress`, `chunked`, `expect100`, `proxy`, `proxy_auth`, `proxy_headers`, `ssl`, `traces`, `timer`, `session`, … |
| **Key mutable properties** | `method`, `url`, `original_url`, `headers` (CIMultiDict), `skip_auto_headers`, `_body` (payload or `None`), `_continue` (future for 100‑Continue), `proxy`, `proxy_auth`, `proxy_headers`, `ssl` (normalized). |
| **Body handling** |
| • **`body` getter** – returns the current payload or `b""` for an empty body (kept for compatibility). |
| • **`body` setter** – **deprecated**; closes any existing payload, warns if it needs manual close, then delegates to `_update_body`. |
| • **`update_body_from_data(data, _stacklevel=3)`** – synchronous conversion of *data* (bytes, `FormData`, custom payload, etc.) into a `payload.Payload` instance, updates related headers (`Content‑Length`, `Transfer‑Encoding`, payload‑specific headers). |
| • **`update_body(body)`** – **async** API that safely closes the previous payload (`await self._body.close()`) before re‑building the body via `_update_body`. This is the **recommended** way to change the request body after creation. |
| **Header handling** |
| • `update_headers()` – builds the initial header dict and always sets `Host`. |
| • `update_auto_headers(skip_auto_headers)` – inserts default `Accept`, `Accept‑Encoding`, and `User‑Agent` unless the user explicitly disabled them. |
| • `update_content_encoding(data)` – applies compression (`gzip`, `deflate`, `br`, `zstd`) if `compress` is truthy and no `Content‑Encoding` already exists. |
| • `update_transfer_encoding()` – adds/validates `Transfer‑Encoding: chunked` respecting existing `Content‑Length`. |
| • `update_auth(auth, trust_env)` – adds `Authorization` header when a `BasicAuth` is present. |
| **Cookie handling** – `update_cookies()` builds a `Cookie` header from a mapping or `SimpleCookie`, preserving RFC‑6265 parsing. |
| **Proxy handling** – `update_proxy(proxy, proxy_auth, proxy_headers)` stores proxy configuration; validates types. |
| **SSL handling** – Normalises the *ssl* argument using `_merge_ssl_params`. |
| **Sending** |
| • `write_bytes(writer, conn, content_length)` – streams the request body (or nothing) to the transport, handling `100‑Continue`, compression, chunked encoding, and proper error mapping. |
| • `send(conn)` – builds the request line (`METHOD path HTTP/1.1`), writes headers (with possible auto‑header injection), starts the writer task (if needed), creates a `ClientResponse` instance, and returns it. |
| **Cleanup** – `close()`, `terminate()`, and internal callbacks clear the writer task and cancel pending I/O. |
| **Tracing** – `_on_chunk_request_sent` and `_on_headers_request_sent` invoke any attached `Trace` objects. |

---

## 3. Dependencies & Relationships  

### 3.1 Direct Imports  

| Module | Reason for import |
|--------|-------------------|
| `asyncio`, `traceback`, `warnings`, `sys`, `codecs`, `contextlib`, `functools`, `io`, `re` | Core Python utilities used throughout the module (event‑loop, error handling, text decoding, etc.). |
| `collections.abc.Mapping` | Type hint for cookie and header mappings. |
| `hashlib` (`md5`, `sha1`, `sha256`) | Fingerprint verification. |
| `http.cookies` (`Morsel`, `SimpleCookie`) | Cookie parsing and generation. |
| `types` (`MappingProxyType`, `TracebackType`) | Immutable view for header/cookie parameters and typing of tracebacks. |
| `typing` (various) | Static typing. |
| `attr` | Used for the immutable `ContentDisposition` data class. |
| `multidict` (`CIMultiDict`, `CIMultiDictProxy`, `MultiDict`, `MultiDictProxy`) | Case‑insensitive header containers. |
| `yarl` (`URL`) | URL handling. |
| **Local aiohttp packages** | |
| `.` (`hdrs`, `helpers`, `http`, `multipart`, `payload`) | Constants, helper functions, HTTP version definitions, multipart parsing, and payload registry. |
| `._cookie_helpers` | Functions for robust cookie header parsing. |
| `abc` (`AbstractStreamWriter`) | Abstract writer protocol. |
| `client_exceptions` | Custom exception hierarchy (`ClientConnectionError`, `ClientResponseError`, etc.). |
| `compression_utils` (`HAS_BROTLI`, `HAS_ZSTD`) | Detect optional compression algorithms. |
| `formdata` (`FormData`) | Helper for building multipart/form‑data bodies. |
| `streams` (`StreamReader`) | Implementation of an async readable stream for response bodies. |
| `typedefs` (`DEFAULT_JSON_DECODER`, `LooseCookies`, `LooseHeaders`, etc.) | Shared type aliases and defaults. |
| `ssl` (optional) | SSL/TLS context handling, guarded by `TYPE_CHECKING`. |

### 3.2 Interaction with Other aiohttp Components  

| Component | How `client_reqrep` uses it | Who uses `client_reqrep` |
|-----------|-----------------------------|---------------------------|
| **`ClientSession`** (`aiohttp.client`) | Passed at construction time (`session` argument) to store a reference for tracing, charset resolution, and to expose `session` via `ClientRequest.session`. The response stores a back‑reference to the session for future operations (e.g., cookie jar). | `ClientSession` creates a `ClientRequest` for each high‑level request (`session.get()`, `session.post()`, …) and later consumes the returned `ClientResponse`. |
| **`Connector`** (`aiohttp.connector`) | The request builds a `ConnectionKey` that the connector uses to pool/reuse connections. The request also receives a concrete `Connection` object in `send(conn)`. | The `Connector` looks up (or creates) a `Connection` based on the request’s `connection_key`. |
| **`Trace`** (`aiohttp.tracing`) | Both request and response call `trace.send_*` methods when headers, chunks, or response data are sent/received. | User‑provided or default tracing objects monitor the request lifecycle. |
| **`payload` module** | Provides the `PAYLOAD_REGISTRY` used to turn arbitrary body data into a concrete `payload.Payload` implementation. Also defines the `Payload` base class used for typing and stream handling. | `ClientRequest` uses it to construct bodies; `ClientResponse` may return a `payload` via its `content` stream. |
| **`multipart`** | Used to parse `Content‑Disposition` headers of a response and to construct multipart bodies from `FormData`. | `ClientResponse.content_disposition` property; `ClientRequest.update_body_from_data` when dealing with `FormData`. |
| **`helpers` & `hdrs`** | Helper functions for header handling, basic auth encoding, MIME parsing, etc.; `hdrs` holds all standard header name constants. | Throughout the module for building and interpreting headers. |
| **`http`** (`aiohttp.http`) | Supplies HTTP version objects (`HttpVersion10`, `HttpVersion11`) and the `StreamWriter` class used to emit request lines/headers and optionally compress/chunk data. | `ClientRequest.send` constructs a `StreamWriter`. |
| **`compression_utils`** | Determines if Brotli/ZSTD compression are available to be advertised in `Accept‑Encoding` and used for request compression. | `ClientRequest` during header generation and during body compression. |
| **`client_exceptions`** | Raises the library‑specific errors that propagate to user code (`ClientResponseError`, `ServerFingerprintMismatch`, …). | Throughout request/response processing when protocol errors, mismatched content types, etc., occur. |

---

## 4. Workflow Description  

Below is a **high‑level call flow** from the moment a user invokes `session.request(method, url, …)` until a `ClientResponse` is returned and consumed.

1. **`ClientSession.request`** creates a **`ClientRequest`** instance.  
   * Normalises arguments (`params` → URL query, `ssl` handling, proxy handling).  
   * Calls a series of `update_*` methods to:
   *   * Build mandatory headers (`Host`).  
   *   * Inject default auto‑headers (`Accept`, `User‑Agent`).  
   *   * Apply cookies, authentication, compression, and transfer‑encoding logic.  
   *   * Resolve the request body (`update_body_from_data`).  

2. **Connector lookup** – `ClientSession._request` asks its `Connector` for a `Connection` using `request.connection_key`. The connector either re‑uses an existing pooled connection or opens a new one (TCP/SSL handshake, optional proxy tunnelling).

3. **`ClientRequest.send(connection)`**  
   * Determines request target (origin‑form, absolute‑form, or authority‑form for CONNECT).  
   * Instantiates a **`StreamWriter`** with callbacks for tracing.  
   * Optionally enables compression (`writer.enable_compression`) and chunked transfer (`writer.enable_chunking`).  
   * Injects *Content‑Type* for POST‑like methods if missing.  
   * Writes the **status line** and **headers** (`writer.write_headers`).  
   * If a body needs to be sent or a 100‑Continue response is awaited, creates an async **writer task** that executes `write_bytes`. Otherwise the request finishes immediately and the protocol timeout starts.  

4. **`write_bytes`** (executed in the writer task)  
   * If *100‑Continue* is expected: sends headers, waits for the future (`self._continue`).  
   * Calls `self._body.write_with_length(writer, content_length)` – each concrete payload knows how to stream itself (e.g., file read, multipart encode).  
   * Handles OS‑level errors, maps them to `ClientOSError` or `ClientConnectionError`.  
   * On success: writes EOF (`writer.write_eof`) and starts the response timeout.  

5. **`ClientResponse` construction** – the `send` method creates a **`ClientResponse`** instance, passing the writer task, the continue‑future, timer, request info, etc.

6. **`ClientResponse.start(connection)`** (called by higher‑level `ClientSession._request`)  
   * Reads the **status line** and **headers** from the connection’s protocol (`protocol.read`).  
   * Handles interim *1xx* responses (loops until a final status code).  
   * Stores headers, raw headers, raw cookie headers.  
   * Registers an EOF callback on the payload (`payload.on_eof(self._response_eof)`).  

7. **User code receives the `ClientResponse`** – typical usage patterns:  

   ```python
   async with session.get(url) as resp:
       data = await resp.json()
   ```

   * The `async with` block triggers `ClientResponse.__aenter__` (sets `_in_context`) and, on exit, `__aexit__` → `release()` → `wait_for_close()`.  

8. **Closing / releasing**  
   * When the response body is fully consumed (`read()`) or the context exits, `_response_eof` marks the response closed, cleans up the writer task, and returns the connection to the pool (`connection.release()`).  

---

## 5. Usage Examples  

> The following snippets are **derived** from the public API and illustrate typical interactions. They are **not** exhaustive but show the most common patterns.

### 5.1 Simple GET request  

```python
import aiohttp
import asyncio

async def fetch():
    async with aiohttp.ClientSession() as session:
        async with session.get('https://api.example.com/data') as resp:
            resp.raise_for_status()          # raise on 4xx/5xx
            data = await resp.json()         # automatically decodes JSON
            return data

asyncio.run(fetch())
```

### 5.2 Posting JSON with custom headers and SSL fingerprint verification  

```python
import aiohttp
import ssl
import hashlib

async def post_data():
    # Compute SHA‑256 fingerprint of the expected server cert
    cert_bytes = open('my_server_cert.der', 'rb').read()
    fingerprint = hashlib.sha256(cert_bytes).digest()

    async with aiohttp.ClientSession() as session:
        async with session.post(
            'https://secure.example.com/submit',
            json={'key': 'value'},
            ssl=aiohttp.Fingerprint(fingerprint),   # verify server cert
            headers={'X-My-Header': 'value'}
        ) as resp:
            return await resp.text()
```

### 5.3 Updating the request body after creation (async)  

```python
import aiohttp
import asyncio

async def upload_file():
    async with aiohttp.ClientSession() as session:
        req = aiohttp.ClientRequest(
            method='PUT',
            url=aiohttp.URL('https://files.example.com/upload'),
            session=session,
        )
        # first body
        await req.update_body(b'initial bytes')

        # later we decide to replace it
        await req.update_body(aiohttp.FormData({'file': open('big.bin', 'rb')}))

        resp = await req.send(await session._connector.connect(req))
        return await resp.text()
```

---

## 6. Notes for Developers  

| Topic | Details & Gotchas |
|-------|-------------------|
| **`body` setter is deprecated** | Directly assigning `request.body = …` bypasses the async cleanup logic and will leak resources (open files, streams). Use `await request.update_body(new_body)` instead. |
| **Content‑Length vs. Chunked** | `update_transfer_encoding` enforces mutual exclusivity. If `Transfer‑Encoding: chunked` is present, `Content‑Length` is forbidden, and vice‑versa. |
| **100‑Continue handling** | When `expect100=True`, the request sends headers, waits for the server to reply with `100 Continue` before streaming the body. The internal future (`self._continue`) is fulfilled on receipt; if the server never replies, the request will block until timeout. |
| **Compression** | The `compress` argument may be a string (e.g., `'gzip'`) or `True` (defaults to `'deflate'`). Compression automatically forces chunked encoding because the final size is unknown. |
| **SSL parameter normalisation** | `_merge_ssl_params` supports the historic arguments `verify_ssl`, `ssl_context`, and `fingerprint`. All are mutually exclusive; mixing them raises `ValueError`. Deprecation warnings are emitted for the old names. |
| **Cookie parsing** | `ClientResponse.cookies` lazily parses raw `Set-Cookie` headers using `parse_set_cookie_headers`, which is more tolerant than the standard `SimpleCookie.load`. The parsed `SimpleCookie` is cached. |
| **Tracing hooks** | The request/response objects call `Trace.send_*` methods at several points (header sent, chunk sent, chunk received). Implementors can hook into these for logging, metrics, or custom debugging. |
| **Connection pooling** | `ConnectionKey` includes a hash of `proxy_headers`. Changing any of these (including the order of proxy headers) results in a *different* key, preventing reuse of a connection that would send the wrong headers. |
| **Response `close` semantics** | Calling `close()` before fully reading the body triggers `_notify_content` which marks the underlying connection as unusable (`_CONNECTION_CLOSED_EXCEPTION`). The connection is then closed, not returned to the pool. |
| **Error mapping** | Low‑level `OSError` or `asyncio.CancelledError` are wrapped into `ClientOSError` / `ClientConnectionError` with a helpful message that contains the request URL. |
| **Async context manager** | `ClientResponse` implements `__aenter__`/`__aexit__`; exiting the context automatically releases the connection regardless of whether the payload was fully consumed. This is the recommended pattern when you only need a subset of the data (e.g., streaming a large file). |
| **Thread safety** | The objects are **not** thread‑safe. All public methods (especially those that mutate state, like `update_body`) must be called from the same event loop that created the request/response. |
| **Testing & backward compatibility** | Several branches exist solely for compatibility with older aiohttp versions (e.g., `url_obj` property, `body` setter, handling of `verify_ssl`). They can be removed in a major version bump but must be kept for the current stable release. |
| **Resource warnings** | `_warn_if_unclosed_payload` emits a `ResourceWarning` when a payload that requires explicit closing is not auto‑closed. It helps developers detect leaks during testing. |

---

*End of documentation for `aiohttp.client_reqrep`.*