# ðŸ“˜ aiohappyeyeballs.types â€“ Type Definitions Module  

*Location*: `venv\Lib\site-packages\aiohappyeyeballs\types.py`  

---  

## 1. Module Purpose  

| Aspect | Description |
|--------|-------------|
| **Responsibility** | Provides concrete typeâ€‘aliases used throughout the *aiohappyeyeballs* package to describe the shape of addressâ€‘info tuples returned by `socket.getaddrinfo` and the signature of a **socket factory** callable. |
| **Why it exists** | The library needs a single, wellâ€‘documented source of truth for these complex typing constructs. By centralising them, the rest of the codebase can import the aliases, keeping type hints readable and avoiding duplication. It also isolates the Pythonâ€‘versionâ€‘specific workaround required for Pythonâ€¯3.9 (importing `Callable` from `typing`). |

---  

## 2. Key Components  

### 2.1 `AddrInfoType`  

```python
AddrInfoType = Tuple[
    Union[int, socket.AddressFamily],
    Union[int, socket.SocketKind],
    int,
    str,
    Tuple,  # type: ignore[type-arg]
]
```

* **What it represents**  
  The tuple structure returned by `socket.getaddrinfo` (or a compatible custom resolver). It matches the CPython signature:

  ```text
  (family, type, proto, canonname, sockaddr)
  ```

* **Elements (in order)**  

| Index | Type (runtime) | Meaning |
|-------|----------------|---------|
| `0`   | `int` **or** `socket.AddressFamily` | Address family (e.g., `AF_INET`, `AF_INET6`). |
| `1`   | `int` **or** `socket.SocketKind`    | Socket type (e.g., `SOCK_STREAM`). |
| `2`   | `int`                                 | Protocol number (often `0`). |
| `3`   | `str`                                 | Canonical name (may be empty). |
| `4`   | `Tuple` (opaque)                      | The raw socket address (e.g., `(host, port)`). The `type: ignore` comment silences a mypy limitation on the generic tuple contents. |

* **Inputs / Outputs** â€“ This is a *type alias*, not a function, so there are no runtime inputs or outputs. It is used exclusively for static analysis and documentation.  

* **Public API** â€“ Exported at module level; other modules import it with `from aiohappyeyeballs.types import AddrInfoType`.  

---

### 2.2 `SocketFactoryType`  

```python
SocketFactoryType = Callable[[AddrInfoType], socket.socket]
```

* **What it represents**  
  The callable signature that creates a new `socket.socket` object given a single `AddrInfoType` tuple. In the library this abstraction allows the user (or tests) to inject custom socketâ€‘creation logic (e.g., for mocks, TLS wrappers, or special socket options).  

* **Signature**  

| Parameter | Type | Description |
|-----------|------|-------------|
| `addrinfo`| `AddrInfoType` | A single addressâ€‘info tuple (as defined above). |

| Return | Type | Description |
|--------|------|-------------|
| `socket.socket` | `socket.socket` | A newlyâ€‘created, readyâ€‘toâ€‘connect socket instance. |

* **Public API** â€“ Exported at module level; components that need to build sockets accept a `SocketFactoryType` argument (or default to the libraryâ€™s builtâ€‘in factory).  

---

## 3. Dependencies & Relationships  

### 3.1 Imports  

| Imported Symbol | Origin | Reason |
|-----------------|--------|--------|
| `socket` | Python standard library | Needed for the `socket` classes (`AddressFamily`, `SocketKind`, and the `socket.socket` return type). |
| `Callable`, `Tuple`, `Union` | `typing` (Pythonâ€¯3.9â€‘compatible) | Used to construct the type aliases. The comment references a CPython issue that prevented importing `Callable` from `collections.abc` on 3.9, hence the temporary import. |

### 3.2 Interaction with the Rest of *aiohappyeyeballs*  

| Component | Relationship |
|-----------|--------------|
| **Resolver / Connection code** (e.g., `aiohappyeyeballs._resolver`, `aiohappyeyeballs._connect`) | **Depends on** `AddrInfoType` to annotate addressâ€‘info structures, and on `SocketFactoryType` to typeâ€‘hint the socketâ€‘factory argument. |
| **Tests / Mocks** | Likely import these aliases to provide correctlyâ€‘typed stub data or custom factories. |
| **Userâ€‘level API** (e.g., `aiohappyeyeballs.connect`) | May expose a `socket_factory` parameter typed with `SocketFactoryType`. |

### 3.3 Position in the Architecture  

* The **types** module is a *leaf* in the dependency graph: it has no runtime logic and only imports from the standard library.  
* It is a **foundation** for all higherâ€‘level modules that deal with networking, ensuring consistent type signatures across the package.  

---  

## 4. Workflow Description  

Because the file only defines aliases, there is no runtime execution flow. The logical â€œworkflowâ€ is the way other modules use these definitions:

1. **Address resolution** â€“ A resolver calls `socket.getaddrinfo`, receives a list of tuples.
2. **Annotation** â€“ The resolver annotates the returned value as `List[AddrInfoType]`.
3. **Socket creation** â€“ When establishing a connection, the code selects an `AddrInfoType` entry and passes it to a function whose signature is `SocketFactoryType`.
4. **Factory call** â€“ The concrete factory (either the libraryâ€™s default or a userâ€‘provided callable) receives the tuple and returns a `socket.socket`.
5. **Further steps** â€“ The socket is then used for I/O (outside the scope of this module).  

---  

## 5. Usage Examples  

> **Note** â€“ Only examples that can be *directly inferred* from the defined aliases are shown. No extra implementation is introduced.

```python
# Example 1 â€“ Using the type aliases in a function signature
from typing import List
import socket

from aiohappyeyeballs.types import AddrInfoType, SocketFactoryType

def default_socket_factory(info: AddrInfoType) -> socket.socket:
    """Create a plain TCP socket based on the addressâ€‘info tuple."""
    family, sock_type, proto, _canonname, _sockaddr = info
    return socket.socket(family, sock_type, proto)

def connect_one_address(
    addrinfo: AddrInfoType,
    factory: SocketFactoryType = default_socket_factory,
) -> socket.socket:
    """Return a connected socket using the supplied factory."""
    s = factory(addrinfo)
    # Unpack the raw sockaddr (the last element of the tuple)
    sockaddr = addrinfo[4]
    s.connect(sockaddr)
    return s
```

```python
# Example 2 â€“ Typeâ€‘checking a list of results from getaddrinfo
import socket
from aiohappyeyeballs.types import AddrInfoType

raw_info: List[AddrInfoType] = socket.getaddrinfo(
    host="example.com", port=80, type=socket.SOCK_STREAM
)
# `raw_info` is now statically typed as List[AddrInfoType]
```

---  

## 6. Notes for Developers  

| Topic | Guidance |
|-------|----------|
| **Pythonâ€‘version compatibility** | The `Callable` import from `typing` is kept for Pythonâ€¯3.9 because `collections.abc.Callable` was not usable due to CPython issue #87131. Once the project drops 3.9 support, the import comment can be removed and the `Callable` can be sourced from `collections.abc`. |
| **`Tuple` element typing** | The final element (`sockaddr`) is deliberately typed as a generic `Tuple` with a `type: ignore` comment. The exact shape varies by address family (`(host, port)`, `(host, port, flowinfo, scopeid)`, etc.). Extending the type to be more precise would require conditional typing or overloads, which the library currently avoids for simplicity. |
| **Immutability** | Both aliases are immutable; they only describe data shapes. Do **not** mutate the tuple elements in place (e.g., replace the family) unless you rebuild the whole tuple to preserve type safety. |
| **Extensibility** | When adding a custom resolver that returns enriched addressâ€‘info (e.g., with TLS metadata), you should define a **new** type alias rather than overloading `AddrInfoType`. This keeps the public contract clear. |
| **Testing** | In unit tests you can construct `AddrInfoType` tuples manually, e.g., `((socket.AF_INET, socket.SOCK_STREAM, 0, "", ("127.0.0.1", 8080)))`. Because the last element is a generic tuple, mypy will accept any structure that matches the runtime expectations. |
| **Circular imports** | Since this module imports only the standardâ€‘library `socket`, it poses no risk of circular dependencies. If future types need to reference projectâ€‘specific classes, place those imports inside `TYPE_CHECKING` blocks to avoid runtime cycles. |

---  

*End of documentation.*