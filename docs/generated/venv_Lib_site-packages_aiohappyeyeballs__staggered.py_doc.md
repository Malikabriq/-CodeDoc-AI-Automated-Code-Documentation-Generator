# üìÑ `aiohappyeyeballs._staggered` ‚Äì Staggered‚ÄëStart Race Helper  

## 1. Module Purpose  

| ‚úÖ | **What it does** |  
|---|------------------|  
|**Core responsibility**|Provides the `staggered_race` coroutine that runs a collection of *coroutine factories* with a configurable start‚Äëdelay between them, returning the result of the first successful coroutine and cancelling the rest. |  
|**Why it exists**|The Happy Eyeballs algorithm (RFC‚ÄØ8305) needs to try multiple connection attempts (e.g., IPv4 vs. IPv6) in parallel but with a staggered start to avoid unnecessary traffic. This helper implements the ‚Äúrace with staggered start‚Äù pattern used by `aiohappyeyeballs` to drive the fallback logic without pulling in a heavyweight concurrency framework. |  

In short, this module isolates the ‚Äúrun‚Äëa‚Äëbunch‚Äëof‚Äëtasks‚Äëstaggered‚Äëand‚Äëpick‚Äëthe‚Äëwinner‚Äù pattern so that the rest of the library can focus on DNS resolution and socket handling.

---

## 2. Key Components  

### 2.1. Constants  

| Name | Value | Meaning |
|------|-------|--------|
| `RE_RAISE_EXCEPTIONS` | `(SystemExit, KeyboardInterrupt)` | Exceptions that must be **re‚Äëraised** immediately (they are not treated as ordinary task failures). |

---

### 2.2. Helper Functions  

#### `_set_result(wait_next: asyncio.Future[None]) -> None`  

* **Purpose** ‚Äì Safely resolves a *control* future used to trigger the start of the next coroutine.  
* **Inputs** ‚Äì `wait_next`: a `Future` that, when completed, signals that the next coroutine may be started.  
* **Outputs** ‚Äì `None`. The function mutates the future.  
* **Logic** ‚Äì Checks `wait_next.done()`. If not, calls `wait_next.set_result(None)`.  
* **Visibility** ‚Äì Internal (prefixed with `_`).  

---

#### `_wait_one(futures: Iterable[asyncio.Future[Any]], loop: asyncio.AbstractEventLoop) -> Awaitable[_T]`  

* **Purpose** ‚Äì Waits until **any** of the supplied futures completes and returns that future itself.  
* **Inputs**  
  * `futures`: any iterable of `asyncio.Future` objects (tasks, control futures, etc.).  
  * `loop`: the event loop on which the futures run.  
* **Outputs** ‚Äì The *first* future that completes (its result is not awaited here). The return type is generic (`_T`).  
* **Logic**  
  1. Creates `wait_next` ‚Äì a fresh future that will be completed by the callback of the first finished future.  
  2. Registers `_on_completion` as a *done‚Äëcallback* on every future in `futures`. When any future finishes, the callback sets `wait_next` with that future (if not already set).  
  3. Awaits `wait_next`.  
  4. In a `finally` block, removes the callbacks to avoid leaks.  
* **Visibility** ‚Äì Internal.  

---

### 2.3. Public API  

#### `async def staggered_race(  
    coro_fns: Iterable[Callable[[], Awaitable[_T]]],  
    delay: Optional[float],  
    *,  
    loop: Optional[asyncio.AbstractEventLoop] = None,  
) -> Tuple[Optional[_T], Optional[int], List[Optional[BaseException]]]`  

* **Purpose** ‚Äì Execute a series of coroutine *factory* callables (`coro_fns`) with a *staggered start* (controlled by `delay`). The first coroutine that successfully **returns** wins; the rest are cancelled.  

* **Signature**  

| Parameter | Type | Description |
|-----------|------|-------------|
| `coro_fns` | `Iterable[Callable[[], Awaitable[_T]]]` | An ordered collection of *callables* that, when invoked, produce the coroutine to be scheduled. Use `functools.partial` or `lambda` to bind arguments. |
| `delay` | `Optional[float]` | Seconds to wait before launching the *next* coroutine **after** the previous one fails **or** the timer expires. `None` ‚Üí start each coroutine **sequentially** (i.e., wait for failure before starting the next). |
| `loop` | `Optional[asyncio.AbstractEventLoop]` | Event loop to use; defaults to `asyncio.get_running_loop()`. |
| **Return** | `Tuple[Optional[_T], Optional[int], List[Optional[BaseException]]]` | 1Ô∏è‚É£ `winner_result` ‚Äì the value returned by the winning coroutine (or `None` if none succeeded).<br>2Ô∏è‚É£ `winner_index` ‚Äì index of the winning coroutine in `coro_fns` (or `None`).<br>3Ô∏è‚É£ `exceptions` ‚Äì list parallel to the started coroutines; each entry is the exception raised by that coroutine, or `None` for the winner. |

* **Internal workflow** (high‚Äëlevel)  

  1. Prepare the running loop and collections (`exceptions`, `tasks`).  
  2. Define a nested coroutine `run_one_coro` that:  
     * Executes the provided `coro_fn`.  
     * On **exception** (except `SystemExit` / `KeyboardInterrupt`), records it, triggers the *start‚Äënext* future, and returns `None`.  
     * On **success**, returns `(result, index)`.  
  3. Iterate over `coro_fns` lazily, creating a task for each coroutine **as soon as allowed** (either immediately for the first, or after a timer / failure of the previous).  
  4. Use `_wait_one` to wait for either:  
     * The *control future* (`start_next`) ‚Üí indicates it‚Äôs time to start the next coroutine.  
     * One of the running tasks ‚Üí possibly a winner.  
  5. If a task finishes successfully (`done.result()` is truthy), unpack and return the winner together with the `exceptions` list.  
  6. If the iterator is exhausted and no tasks remain, break out ‚Äì there is no winner.  
  7. In the `finally` block, clean up: cancel any pending timer, cancel remaining tasks, and await them (suppressing `CancelledError`) to ensure their exceptions are captured.  
  8. Return `(None, None, exceptions)` when every coroutine failed.  

* **Public exposure** ‚Äì This is the only symbol exported as part of the module‚Äôs public API (implicitly, because the module‚Äôs `__all__` is not defined).  

---

## 3. Dependencies & Relationships  

### 3.1. Imports  

| Module | Imported Symbol(s) | Reason |
|--------|-------------------|--------|
| `asyncio` | core asyncio primitives (`Future`, `Task`, `TimerHandle`, `AbstractEventLoop`, etc.) | To schedule, track, and coordinate asynchronous work. |
| `contextlib` | `suppress` | Simplify cancellation handling in the cleanup section. |
| `typing` | `TYPE_CHECKING`, `Any`, `Awaitable`, `Callable`, `Iterable`, `List`, `Optional`, `Set`, `Tuple`, `TypeVar`, `Union` | Type hints for static analysis & documentation. |

### 3.2. Interaction with the rest of the project  

* **Who does this module depend on?**  
  * Pure Python stdlib (`asyncio`, `contextlib`, `typing`).  
  * No internal `aiohappyeyeballs` imports ‚Äì it is deliberately isolated, making it reusable by any part of the project that needs a staggered race.  

* **Who likely depends on this module?**  
  * The core Happy‚ÄëEyeballs implementation (`aiohappyeyeballs._happyeyeballs`, etc.) which must try multiple DNS‚Äëresolved addresses with staggered connection attempts.  
  * Any higher‚Äëlevel utility that wants to ‚Äútry several strategies, start them with a delay, and keep the first that works‚Äù.  

* **Architectural placement**  
  * **Utility layer** ‚Äì Provides a generic concurrency primitive used by the **network‚Äëconnection** layer of the library.  
  * Keeps the networking code clean by abstracting the ‚Äúrace‚Äëwith‚Äëdelay‚Äù pattern.

---

## 4. Workflow Description  

Below is a step‚Äëby‚Äëstep trace of what happens when `staggered_race` is invoked.

```
staggered_race(coro_fns, delay, loop=None)
‚îÇ
‚îú‚îÄ‚ñ∫ Resolve the running event loop.
‚îÇ
‚îú‚îÄ‚ñ∫ Initialise:
‚îÇ    ‚Ä¢ exceptions = []                     # will grow with each started coroutine
‚îÇ    ‚Ä¢ tasks = set()                       # holds asyncio.Task objects
‚îÇ
‚îú‚îÄ‚ñ∫ Define inner coroutine run_one_coro(...)
‚îÇ
‚îú‚îÄ‚ñ∫ Create an iterator over coro_fns.
‚îÇ
‚îú‚îÄ‚ñ∫ Loop: (outer while True)
‚îÇ    ‚îÇ
‚îÇ    ‚îú‚îÄ‚ñ∫ Pull next coroutine factory (coro_fn) if any.
‚îÇ    ‚îÇ    ‚îî‚îÄ If found:
‚îÇ    ‚îÇ         ‚Ä¢ Increment index.
‚îÇ    ‚îÇ         ‚Ä¢ Append None to `exceptions` (placeholder).
‚îÇ    ‚îÇ         ‚Ä¢ Create a Future `start_next` ‚Äì controls when the *next* coroutine may be spawned.
‚îÇ    ‚îÇ         ‚Ä¢ Schedule `run_one_coro(coro_fn, index, start_next)` as a Task, add to `tasks`.
‚îÇ    ‚îÇ         ‚Ä¢ If delay is not None ‚Üí schedule a timer (call_later) that will call `_set_result(start_next)` after `delay` seconds.
‚îÇ    ‚îÇ
‚îÇ    ‚îî‚îÄ‚ñ∫ If iterator exhausted *and* no tasks are running ‚Üí break outer loop (no winner).
‚îÇ
‚îú‚îÄ‚ñ∫ Inner while: (while tasks or start_next)
‚îÇ    ‚îÇ
‚îÇ    ‚îú‚îÄ‚ñ∫ Wait for the *first* of:
‚îÇ    ‚îÇ        ‚Ä¢ Any task in `tasks`
‚îÇ    ‚îÇ        ‚Ä¢ The control future `start_next`
‚îÇ    ‚îÇ    using `_wait_one`.
‚îÇ    ‚îÇ
‚îÇ    ‚îú‚îÄ‚ñ∫ If the returned object is `start_next`:
‚îÇ    ‚îÇ        ‚Ä¢ Means previous coroutine failed or timer elapsed.
‚îÇ    ‚îÇ        ‚Ä¢ Cancel the timer (if any), clear `start_next`.
‚îÇ    ‚îÇ        ‚Ä¢ Break inner loop ‚Üí outer loop will schedule the next coroutine (if any).
‚îÇ    ‚îÇ
‚îÇ    ‚îî‚îÄ‚ñ∫ Else we got a completed task:
‚îÇ         ‚Ä¢ Remove it from `tasks`.
‚îÇ         ‚Ä¢ If `task.result()` is a tuple (result, idx) ‚Üí we have a winner.
‚îÇ               ‚Äì Return `(result, idx, exceptions)`.
‚îÇ         ‚Ä¢ Otherwise the task failed; its exception has already been stored
‚îÇ           by `run_one_coro` and the timer has been (or will be) triggered.
‚îÇ
‚îú‚îÄ‚ñ∫ Cleanup (finally):
‚îÇ    ‚Ä¢ Cancel any pending `start_next_timer`.
‚îÇ    ‚Ä¢ Cancel all remaining tasks; await them while suppressing CancelledError
‚îÇ      so that their exceptions are recorded.
‚îÇ
‚îî‚îÄ‚ñ∫ Return `(None, None, exceptions)` if no coroutine succeeded.
```

*Key points*  

* The **first** coroutine starts immediately.  
* Subsequent coroutines start **only** when the preceding one fails **or** when the configured `delay` elapses (whichever comes first).  
* The moment a coroutine succeeds, all other pending work is cancelled and the result is propagated.  
* The function guarantees that the `exceptions` list aligns with the order of **started** coroutines, not the original `coro_fns` length (unstarted factories are simply omitted).  

---

## 5. Usage Examples  

> The examples assume you have imported the function:

```python
from aiohappyeyeballs._staggered import staggered_race
import asyncio
```

### 5.1. Simple ‚Äútry two connections‚Äù scenario  

```python
async def conn_ipv4():
    # pretend this tries IPv4 and raises on failure
    await asyncio.sleep(0.3)          # simulate latency
    raise OSError("IPv4 unreachable")

async def conn_ipv6():
    await asyncio.sleep(0.1)          # faster, succeeds
    return "connected via IPv6"

# Wrap factories (no arguments needed here)
result, idx, excs = await staggered_race(
    coro_fns=[conn_ipv4, conn_ipv6],
    delay=0.2,                        # start IPv6 after 200‚ÄØms if IPv4 fails
)

print(result)   # ‚Üí "connected via IPv6"
print(idx)      # ‚Üí 1 (index of the IPv6 factory)
print(excs)     # ‚Üí [OSError(...), None]
```

### 5.2. Sequential fallback (no overlap)  

```python
# delay=None ‚Üí start the next only after the previous fails
result, idx, excs = await staggered_race(
    coro_fns=[conn_ipv4, conn_ipv6],
    delay=None,
)
```

### 5.3. Passing arguments with `functools.partial`

```python
from functools import partial

async def fetch(url: str, timeout: float) -> str:
    await asyncio.sleep(timeout)  # simulate network latency
    if "bad" in url:
        raise RuntimeError("fetch failed")
    return f"data from {url}"

coro_fns = [
    partial(fetch, "https://example.com/bad", 0.05),
    partial(fetch, "https://example.com/good", 0.2),
]

result, idx, excs = await staggered_race(coro_fns, delay=0.1)
```

These examples illustrate the intended way to supply **factory callables** and control the staggered start with the `delay` argument.

---

## 6. Notes for Developers  

| Topic | Guidance / Pitfalls |
|-------|----------------------|
| **Coroutine factories** | `staggered_race` expects *callables that return a coroutine object* **when called**, **not** coroutine objects themselves. Passing a coroutine directly will start it immediately, bypassing the staggered logic. |
| **Exception handling** | Only `BaseException` subclasses other than `SystemExit` and `KeyboardInterrupt` are captured as ordinary failures. Those two are re‚Äëraised to allow the process to terminate correctly. |
| **Cancellation semantics** | When a winner is found, all remaining tasks are cancelled in the `finally` block. The cancellation is *cooperative*: if a task does not honor `CancelledError`, it may remain pending, potentially leaking resources. Ensure any coroutines used with this helper propagate `CancelledError`. |
| **Timer cancellation** | The timer (`start_next_timer`) is canceled as soon as the next coroutine is scheduled. If `delay` is `None` no timer is created. |
| **Resource cleanup** | The `finally` block guarantees that (1) any pending timer is cancelled; (2) all tasks are cancelled and awaited, so their exceptions are stored in the `exceptions` list. This prevents ‚Äúdangling‚Äù tasks that could interfere with later event‚Äëloop work. |
| **Ordering of `exceptions`** | The list only contains entries for coroutines that were *actually started*. If the iterator is exhausted early (e.g., a winner appears after the first few attempts), later factories never run and thus have no entry. |
| **Thread‚Äësafety** | The function is `async`‚Äëonly and must be called from an event loop thread. It does not protect against being invoked from multiple loops simultaneously; each call creates its own independent state. |
| **Performance** | The implementation uses callbacks (`add_done_callback`) rather than `await asyncio.wait(..., return_when=FIRST_COMPLETED)` to avoid creating extra intermediate futures. This keeps overhead low, which is important for the fast‚Äëpath connection‚Äëestablishment use case. |
| **Python version** | The file imports `Callable` from `typing` for Python¬†3.9 compatibility (see comment at the top). It will work on any Python version supported by the package (‚â•‚ÄØ3.9). |
| **Extensibility** | If additional signaling is needed (e.g., a *maximum total time* limit), callers can wrap `staggered_race` with `asyncio.wait_for`. The internal design (separate `run_one_coro`, a controllable `start_next` future, and timer handles) makes it easy to add logging or metrics without touching the core loop. |

---

*End of documentation.*