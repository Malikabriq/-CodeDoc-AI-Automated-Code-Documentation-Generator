# aiohttp.abc – Abstract Base Classes for aiohttp

## 1. Module Purpose
### What this file is responsible for
`aiohttp.abc` defines **abstract base classes (ABCs)** that form the contract for the core components of the **aiohttp** web framework and client. These ABCs describe the required public API for:

* Routers & match‑info objects used during request dispatching  
* View objects (class‑based request handlers)  
* DNS resolvers used by the client connector  
* Cookie jars that store and retrieve HTTP cookies  
* Stream writers that send HTTP responses to the transport  
* Access loggers that write request/response information to a logger  

By providing these contracts, the module enables **pluggable implementations** (e.g., custom routers, resolvers, cookie jars) while keeping the rest of the library type‑safe and well‑documented.

### Why it exists in the project
* **Extensibility** – Users can replace the default implementations with their own by subclassing the appropriate ABC.
* **Static typing & IDE support** – The abstract signatures give mypy, Pyright, and IDEs a clear contract to check against.
* **Separation of concerns** – Core logic (e.g., `aiohttp.web.Application`) can depend on interfaces rather than concrete classes, reducing coupling.
* **Documentation hub** – All high‑level contracts are co‑located, making it easy for developers to discover what methods they must implement.

---

## 2. Key Components

### 2.1 `AbstractRouter`
```python
class AbstractRouter(ABC):
    def __init__(self) -> None
    def post_init(self, app: Application) -> None
    @property
    def frozen(self) -> bool
    def freeze(self) -> None
    @abstractmethod
    async def resolve(self, request: Request) -> "AbstractMatchInfo"
```
* **Purpose** – Describes the router that maps an incoming `Request` to a handler.
* **Inputs** – `request`: a `aiohttp.web.Request` (or subclass) instance.
* **Outputs** – An `AbstractMatchInfo` object containing the resolved handler and related metadata.
* **Internal logic** – Holds a `_frozen` flag that, once set via `freeze()`, prevents further modifications (e.g., adding routes). Sub‑classes may implement `post_init` to perform actions after the `Application` is created.
* **Public API** – `resolve()` (async), `freeze()`, `post_init()`, `frozen` property.

---

### 2.2 `AbstractMatchInfo`
```python
class AbstractMatchInfo(ABC):
    @property
    @abstractmethod
    def handler(self) -> Callable[[Request], Awaitable[StreamResponse]]

    @property
    @abstractmethod
    def expect_handler(self) -> Callable[[Request], Awaitable[Optional[StreamResponse]]]

    @property
    @abstractmethod
    def http_exception(self) -> Optional[HTTPException]

    @abstractmethod
    def get_info(self) -> Dict[str, Any]

    @property
    @abstractmethod
    def apps(self) -> Tuple[Application, ...]

    @abstractmethod
    def add_app(self, app: Application) -> None

    @abstractmethod
    def freeze(self) -> None
```
* **Purpose** – Represents the outcome of routing: which handler to invoke, any `Expect` (100‑continue) handler, possible HTTP exception, and the stack of nested `Application` objects.
* **Inputs** – Not directly called; created by a router implementation.
* **Outputs** – Exposes:
  * `handler` – callable that receives a `Request` and returns an awaitable `StreamResponse`.
  * `expect_handler` – optional callable for 100‑continue handling.
  * `http_exception` – optional `HTTPException` raised during routing.
* **Internal logic** – Provides methods to introspect routing info (`get_info`), to manage nested apps (`add_app`), and to make the match info immutable (`freeze`).
* **Public API** – All listed abstract properties/methods.

---

### 2.3 `AbstractView`
```python
class AbstractView(ABC):
    def __init__(self, request: Request) -> None
    @property
    def request(self) -> Request
    @abstractmethod
    def __await__(self) -> Generator[None, None, StreamResponse]
```
* **Purpose** – Base class for **class‑based views** (CBVs). The view instance is created with a request and is awaited to produce a response.
* **Inputs** – `request`: the current `Request`.
* **Outputs** – When awaited, yields a `StreamResponse`.
* **Internal logic** – Stores the request; concrete subclasses implement `__await__` to perform I/O and return a response.
* **Public API** – `request` property and the awaitable protocol.

---

### 2.4 `ResolveResult` (TypedDict)
```python
class ResolveResult(TypedDict):
    hostname: str
    host: str
    port: int
    family: int
    proto: int
    flags: int
```
* **Purpose** – Structured result returned by a DNS resolver (`AbstractResolver.resolve`).  
* **Fields** – Hostname, resolved IP (`host`), port, address family, protocol, and resolver flags.  
* **No logic** – Pure data container used for type‑checking.

---

### 2.5 `AbstractResolver`
```python
class AbstractResolver(ABC):
    @abstractmethod
    async def resolve(
        self,
        host: str,
        port: int = 0,
        family: socket.AddressFamily = socket.AF_INET,
    ) -> List[ResolveResult]

    @abstractmethod
    async def close(self) -> None
```
* **Purpose** – Describes the asynchronous DNS resolver used by HTTP client connectors.
* **Inputs** – `host`: hostname to resolve; optional `port` and `family` (AF_INET, AF_INET6, etc.).
* **Outputs** – List of `ResolveResult` dictionaries.
* **Internal logic** – Implementations perform asynchronous DNS queries (e.g., using `aiodns`, system resolver, or a cache). `close()` releases resources (e.g., sockets, thread pools).
* **Public API** – `resolve()` and `close()`.

---

### 2.6 `AbstractCookieJar`
```python
class AbstractCookieJar(Sized, IterableBase):
    def __init__(self, *, loop: Optional[asyncio.AbstractEventLoop] = None) -> None
    @property
    @abstractmethod
    def quote_cookie(self) -> bool

    @abstractmethod
    def clear(self, predicate: Optional[ClearCookiePredicate] = None) -> None

    @abstractmethod
    def clear_domain(self, domain: str) -> None

    @abstractmethod
    def update_cookies(self, cookies: LooseCookies, response_url: URL = URL()) -> None

    def update_cookies_from_headers(self, headers: Sequence[str], response_url: URL) -> None

    @abstractmethod
    def filter_cookies(self, request_url: URL) -> "BaseCookie[str]"
```
* **Purpose** – Defines the contract for a **cookie storage** used by the client side of aiohttp.
* **Key methods**:
  * `quote_cookie` – whether to quote cookie values when sending.
  * `clear()` – remove all cookies or those matching a predicate.
  * `clear_domain()` – purge cookies for a domain and its sub‑domains.
  * `update_cookies()` – add/additional cookie mappings, optionally scoped to a URL.
  * `update_cookies_from_headers()` – convenience wrapper that parses raw `Set-Cookie` header strings (uses `parse_set_cookie_headers` from `. _cookie_helpers`).
  * `filter_cookies()` – produce a `BaseCookie` instance containing only cookies applicable to a given request URL (respecting domain, path, secure, etc.).
* **Iterable** – Implements `__len__` (via `Sized`) and iteration over underlying `Morsel` objects.
* **Public API** – All abstract methods plus the concrete helper `update_cookies_from_headers`.

---

### 2.7 `AbstractStreamWriter`
```python
class AbstractStreamWriter(ABC):
    buffer_size: int = 0
    output_size: int = 0
    length: Optional[int] = 0

    @abstractmethod
    async def write(self, chunk: Union[bytes, bytearray, memoryview]) -> None

    @abstractmethod
    async def write_eof(self, chunk: bytes = b"") -> None

    @abstractmethod
    async def drain(self) -> None

    @abstractmethod
    def enable_compression(self, encoding: str = "deflate", strategy: Optional[int] = None) -> None

    @abstractmethod
    def enable_chunking(self) -> None

    @abstractmethod
    async def write_headers(self, status_line: str, headers: "CIMultiDict[str]") -> None

    def send_headers(self) -> None
```
* **Purpose** – Defines the low‑level writer used by `StreamResponse` and server protocols to emit HTTP response data.
* **Key responsibilities**:
  * Buffer management (`buffer_size`, `output_size`, `length`).
  * Writing data chunks (`write`), final chunk (`write_eof`), and flushing (`drain`).
  * Enabling **compression** (e.g., `deflate`, `gzip`) and **chunked transfer encoding**.
  * Writing the **status line** and headers (`write_headers`).
  * `send_headers()` – legacy hook for writers that buffer headers; default does nothing.
* **Public API** – All abstract methods described above, plus the concrete `send_headers`.

---

### 2.8 `AbstractAccessLogger`
```python
class AbstractAccessLogger(ABC):
    __slots__ = ("logger", "log_format")

    def __init__(self, logger: logging.Logger, log_format: str) -> None
    @abstractmethod
    def log(self, request: BaseRequest, response: StreamResponse, time: float) -> None
    @property
    def enabled(self) -> bool
```
* **Purpose** – Provides the interface for components that write **access logs** (e.g., standard Apache‑style logs) for each request/response pair.
* **Inputs** – 
  * `logger`: a `logging.Logger` instance to emit the formatted message.
  * `log_format`: a string template (e.g., `'%a %t "%r" %s %b'`).
* **Method** – `log()` receives the request, the response, and the elapsed time (`time` in seconds) and must emit a log entry.
* **Property** – `enabled` can be overridden to disable logging without removing the logger altogether; defaults to `True`.
* **Public API** – Constructor, `log`, and `enabled`.

---

## 3. Dependencies & Relationships

### 3.1 Imports
| Imported module | Reason / usage |
|-----------------|----------------|
| `asyncio` | Event‑loop handling for `AbstractCookieJar`. |
| `logging` | Base class for `AbstractAccessLogger`. |
| `socket` | Types for DNS resolver (`socket.AddressFamily`). |
| `abc` (`ABC`, `abstractmethod`) | To define abstract base classes. |
| `collections.abc` (`Sized`) | To make `AbstractCookieJar` sized. |
| `http.cookies` (`BaseCookie`, `Morsel`) | Cookie handling types. |
| `typing` (`TYPE_CHECKING`, `Any`, `Awaitable`, `Callable`, `Dict`, `Generator`, `Iterable`, `List`, `Optional`, `Sequence`, `Tuple`, `TypedDict`, `Union`) | Type hints. |
| `multidict` (`CIMultiDict`) | Immutable case‑insensitive mapping for HTTP headers. |
| `yarl` (`URL`) | URL representation for cookie‑jar and resolver contexts. |
| `. _cookie_helpers` (`parse_set_cookie_headers`) | Helper to parse raw `Set-Cookie` header strings. |
| `. typedefs` (`LooseCookies`) | Alias for accepted cookie input types. |
| `if TYPE_CHECKING` block imports (`Application`, `HTTPException`, `BaseRequest`, `Request`, `StreamResponse`) | For static type checking without runtime imports. |

### 3.2 Interaction with other project components
* **Routers & Applications** – `AbstractRouter` is used by `aiohttp.web.Application`. The concrete router (e.g., `UrlDispatcher`) subclasses it and is stored in the application for request dispatch.
* **MatchInfo** – `AbstractMatchInfo` objects are produced by a router’s `resolve` method and later consumed by the request handling pipeline to invoke the proper handler.
* **Views** – `AbstractView` is the base for class‑based request handlers (e.g., `aiohttp.web.View`). When a request is routed to a view class, aiohttp creates an instance and awaits it.
* **DNS Resolver** – `AbstractResolver` is referenced by `aiohttp.connector.BaseConnector` (client side). The default implementation (`aiohttp.resolver.DefaultResolver`) fulfills this contract.
* **Cookie Jar** – `AbstractCookieJar` is used by `aiohttp.client_reqrep.ClientResponse` and `aiohttp.client_reqrep.ClientRequest` to store cookies across requests.
* **Stream Writer** – `AbstractStreamWriter` underlies `aiohttp.web_protocol.StreamWriter` which is employed by the server protocol to send HTTP responses.
* **Access Logger** – `AbstractAccessLogger` is instantiated by `aiohttp.web_log.AccessLogger` (or user‑provided subclass) and called after each request to produce logs.

### 3.3 Who depends on this module?
* Concrete implementations (e.g., `aiohttp.web.UrlDispatcher`, `aiohttp.web.Response`, `aiohttp.client.ClientSession`, `aiohttp.web_log.AccessLogger`) import these ABCs to type‑check and to call abstract methods.
* Tests, third‑party extensions, or user code that wants to provide custom routers, resolvers, cookie jars, or loggers will subclass these ABCs.

### 3.4 How it fits into the architecture
`aiohttp.abc` sits at the *interface layer*—the **contract** between the high‑level HTTP server/client components and the pluggable, possibly user‑supplied, low‑level implementations. It enables **dependency inversion**: the rest of the framework works against abstractions instead of concrete classes, allowing runtime substitution and easier testing (e.g., mock resolvers).

---

## 4. Workflow Description

1. **Application start‑up**
   * `aiohttp.web.Application` creates a router instance (default: `UrlDispatcher`) which is a subclass of `AbstractRouter`.
2. **Route registration**
   * Routes are added to the router (concrete method). No abstract method is involved, but the router may enforce that it isn’t `frozen`.
3. **Incoming request**
   * The server protocol receives the raw HTTP request and builds a `Request` object.
4. **Routing**
   * `router.resolve(request)` (async) is called.
   * Implementation returns an `AbstractMatchInfo` containing:
     * `handler` (callable to process the request)
     * `expect_handler` (optional, for `100-continue`)
     * `apps` stack (nested sub‑applications)
5. **MatchInfo finalisation**
   * The framework may call `match_info.freeze()` to prohibit later `add_app` calls.
6. **Handler execution**
   * For function‑based handlers: `await handler(request)`.
   * For class‑based handlers: an `AbstractView` subclass is instantiated with the request, then `await view_instance`.
7. **Response preparation**
   * The handler returns a `StreamResponse` (or subclass) which holds a reference to an `AbstractStreamWriter`.
   * The response calls `writer.write_headers(...)`, then writes body chunks via `writer.write(...)` / `writer.write_eof(...)`.
   * Optional compression or chunked encoding is enabled via `writer.enable_compression(...)` / `writer.enable_chunking()`.
8. **Cookie handling (client side)**
   * When a response arrives, the `AbstractCookieJar` associated with the client updates its store:
     * `update_cookies_from_headers(headers, response_url)` parses `Set-Cookie` headers and stores cookies.
   * Future requests call `filter_cookies(request_url)` to attach the correct `Cookie` header.
9. **DNS resolution (client side)**
   * When a request needs to connect, the connector asks its resolver:
     * `await resolver.resolve(host, port, family)`.
   * The list of `ResolveResult` objects is used to open a socket.
   * When the connector shuts down, `await resolver.close()` is called.
10. **Access logging**
    * After response is sent, the server creates/uses an `AbstractAccessLogger` implementation.
    * Calls `logger.log(request, response, elapsed_time)`.
    * If the logger’s `enabled` property is `False`, the call is a no‑op.

---

## 5. Usage Examples

Below are minimal examples that illustrate how a developer might **extend** the abstractions defined in this module. The code is *inferable* from the signatures and does not rely on any hidden implementation details.

### 5.1 Custom Router

```python
from aiohttp.abc import AbstractRouter, AbstractMatchInfo
from aiohttp.web import Request, StreamResponse, Application

class SimpleMatchInfo(AbstractMatchInfo):
    def __init__(self, handler):
        self._handler = handler
        self._expect_handler = None
        self._http_exception = None
        self._apps = ()

    @property
    def handler(self):
        return self._handler

    @property
    def expect_handler(self):
        return self._expect_handler

    @property
    def http_exception(self):
        return self._http_exception

    def get_info(self):
        return {"handler": self._handler}

    @property
    def apps(self):
        return self._apps

    def add_app(self, app: Application) -> None:
        self._apps = (app,) + self._apps

    def freeze(self) -> None:
        # nothing to freeze in this simple example
        pass


class EchoRouter(AbstractRouter):
    async def resolve(self, request: Request) -> AbstractMatchInfo:
        async def echo_handler(req: Request) -> StreamResponse:
            resp = StreamResponse()
            await resp.prepare(req)
            await resp.write(b"Echo")
            return resp

        return SimpleMatchInfo(echo_handler)
```

*The router always resolves to a single handler that returns the string `Echo`.*

### 5.2 Custom DNS Resolver

```python
import socket
from aiohttp.abc import AbstractResolver, ResolveResult

class StaticResolver(AbstractResolver):
    async def resolve(self, host: str, port: int = 0,
                      family: socket.AddressFamily = socket.AF_INET) -> list[ResolveResult]:
        # Always resolves "example.com" to 127.0.0.1; otherwise raises.
        if host == "example.com":
            return [{
                "hostname": host,
                "host": "127.0.0.1",
                "port": port,
                "family": socket.AF_INET,
                "proto": 0,
                "flags": 0,
            }]
        raise OSError("host not found")

    async def close(self) -> None:
        pass
```

*The resolver can be passed to `aiohttp.TCPConnector(resolver=StaticResolver())`.*

### 5.3 Custom Cookie Jar

```python
from aiohttp.abc import AbstractCookieJar
from yarl import URL
from typing import Mapping

class InMemoryCookieJar(AbstractCookieJar):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._store: dict[Tuple[str, str], str] = {}   # (domain, name) -> value

    @property
    def quote_cookie(self) -> bool:
        return False

    def clear(self, predicate=None):
        if predicate is None:
            self._store.clear()
        else:
            for key in list(self._store):
                morsel = self._to_morsel(key)
                if predicate(morsel):
                    del self._store[key]

    def clear_domain(self, domain: str) -> None:
        for key in list(self._store):
            if key[0].endswith(domain):
                del self._store[key]

    def update_cookies(self, cookies: Mapping[str, str], response_url: URL = URL()):
        for name, value in cookies.items():
            self._store[(response_url.host or "", name)] = value

    def filter_cookies(self, request_url: URL):
        from http.cookies import SimpleCookie
        cookie = SimpleCookie()
        for (domain, name), value in self._store.items():
            if request_url.host and request_url.host.endswith(domain):
                cookie[name] = value
        return cookie
```

*The jar stores cookies in a simple dictionary and respects domain matching when filtering.*

---

## 6. Notes for Developers

| Area | Guidance / Pitfalls |
|------|---------------------|
| **Freezing** | Both `AbstractRouter` and `AbstractMatchInfo` expose a *freeze* operation. Implementations must ensure that after `freeze()` is called, mutating operations (e.g., adding routes, appending to the apps stack) raise appropriate exceptions. Forgetting to enforce this can lead to subtle bugs where routes are added after the server has started. |
| **`post_init`** | The method is *not* abstract to preserve backward compatibility. If you need to perform router‑specific initialization that depends on the `Application` (e.g., accessing app settings), override it, but remember to call `super().post_init(app)` only if the parent implements additional logic in the future. |
| **`AbstractMatchInfo` immutability** | Once a request is being processed, the match info should be immutable. The `freeze()` contract guarantees that `add_app` cannot be called afterwards. Concrete classes should raise `RuntimeError` (or a custom exception) if mutation is attempted after freezing. |
| **Cookie handling** | `AbstractCookieJar` implements the iterator protocol via the `IterableBase` alias. When providing a concrete implementation, ensure `__len__` and `__iter__` are correctly defined to avoid `TypeError` when the jar is used in `len(jar)` or for‑loops. |
| **Header parsing** | `update_cookies_from_headers` uses the helper `parse_set_cookie_headers`. The helper returns a mapping compatible with `LooseCookies`. If you override this method, make sure the conversion respects duplicate cookie names and the RFC‑6265 rules. |
| **StreamWriter responsibilities** | The writer must correctly handle *partial* writes, back‑pressure (`drain()`), and proper ordering of header vs. body emission. Compression (`enable_compression`) and chunking (`enable_chunking`) are mutually exclusive in many HTTP implementations; concrete writers should document the allowed combination. |
| **Access logger `enabled`** | The default implementation always returns `True`. If you create a logger that can be toggled at runtime, override this property to respect configuration changes. |
| **Type checking** | The module uses `if TYPE_CHECKING:` blocks to avoid runtime imports that would cause circular dependencies. When extending any ABC, import the concrete types at runtime if needed (e.g., `from aiohttp.web import Request`). |
| **Async signatures** | All async methods (`resolve`, `write`, `write_eof`, `drain`, `close`) must be awaited by callers. Forgetting to `await` them can lead to “coroutine was never awaited” warnings and broken connections. |
| **Exception handling** | `AbstractMatchInfo.http_exception` can carry a pre‑raised `HTTPException`. The request handling pipeline should check this attribute and send the exception's response instead of invoking the handler. Ensure your router implementation populates this field correctly when a route matches but raises (e.g., 404). |
| **Compatibility** | The ABCs are part of `aiohttp`'s public API. Adding new abstract methods or changing signatures will be a breaking change. If new functionality is needed, consider adding *concrete* methods with default implementations before converting them to abstract. |

--- 

*End of documentation for `aiohttp.abc`.*
