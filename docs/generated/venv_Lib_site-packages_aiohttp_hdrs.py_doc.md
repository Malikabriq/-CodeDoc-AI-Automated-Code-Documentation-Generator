# aiohttp `hdrs.py` – HTTP Header & Method Constants  

*File location*: `venv\Lib\site-packages\aiohttp\hdrs.py`  

---

## 1. Module Purpose  

| What the file does | Why it exists in the project |
|--------------------|------------------------------|
| **Defines immutable, canonical constants** for every HTTP request/response method and header name used by *aiohttp*. | Centralises the textual representation of methods and headers so the rest of the codebase can refer to a single source of truth. This eliminates spelling mistakes, provides case‑insensitive behaviour via `multidict.istr`, and enables static analysis / IDE auto‑completion. |
| **Generates helper sets** that contain *all* possible case‑permutations for a few frequently‑used names (e.g., `Host`). | The HTTP/1.1 spec treats header names as case‑insensitive. aiohttp’s parser can recognise any mixed‑case variant; pre‑computing the permutations improves look‑up speed and keeps the parser code simple. |
| **Exports a collection (`METH_ALL`)** of all defined methods. | Useful when validating user‑provided method strings or constructing a generic “allow any method” response. |

In short, `hdrs.py` is the *canonical dictionary* of HTTP vocabulary for the aiohttp library.

---

## 2. Key Components  

### 2.1 HTTP Method Constants  

| Constant | Value | Type | Description |
|----------|-------|------|-------------|
| `METH_ANY` | `*` | `str` | Wild‑card used by routing utilities (e.g., “match any method”). |
| `METH_CONNECT` … `METH_TRACE` | `"CONNECT"`, `"HEAD"`, … | `str` | Upper‑case RFC‑standard method names. |
| `METH_ALL` | `{METH_CONNECT, METH_HEAD, …}` | `Set[str]` | Immutable set containing **all** supported method strings (excluding `METH_ANY`). |

These are simple string literals; they are *final* (`typing.Final`) to signal that they must not be re‑assigned.

### 2.2 Header Name Constants  

All header names are wrapped with `multidict.istr`, a **case‑insensitive string subclass** used by `aiohttp`’s `CIMultiDict` implementation.

```python
ACCEPT: Final[istr] = istr("Accept")
CONTENT_TYPE: Final[istr] = istr("Content-Type")
# … (≈ 80 more)
```

*Why `istr`?*  
When a header is added to a `CIMultiDict`, the dictionary stores the key as an `istr`. This enables O(1) case‑insensitive look‑ups while preserving the original casing for outbound serialization.

### 2.3 Pre‑computed Case‑Permutation Sets  

```python
METH_HEAD_ALL: Final = frozenset(
    map("".join, itertools.product(*zip(METH_HEAD.upper(), METH_HEAD.lower())))
)
METH_CONNECT_ALL: Final = frozenset(
    map("".join, itertools.product(*zip(METH_CONNECT.upper(), METH_CONNECT.lower())))
)
HOST_ALL: Final = frozenset(
    map("".join, itertools.product(*zip(HOST.upper(), HOST.lower())))
)
```

*What they contain* – every possible mixture of upper‑ and lower‑case characters for the given token (e.g., `{'Host', 'hOst', 'HOst', …}`).

*Intended use* – the low‑level HTTP parser (`aiohttp.http_parser`) checks membership against these sets to recognise a header/method regardless of case, without converting the incoming bytes to a canonical form each time.

---

## 3. Dependencies & Relationships  

### 3.1 Imports  

| Module | Reason for import |
|--------|-------------------|
| `itertools` | Generates Cartesian product of upper/lower case characters (`product`). |
| `typing` (`Final`, `Set`) | Provides **type‑hints** signalling immutability and collection types. |
| `multidict.istr` | Wraps header names in a case‑insensitive string class. |

### 3.2 Interaction with the rest of *aiohttp*  

| Dependent component | How it uses `hdrs.py` |
|---------------------|-----------------------|
| **Request/Response objects** (`aiohttp.web_request`, `aiohttp.web_response`) | Import constants to read/write standardized header fields (`request.headers[hdrs.CONTENT_TYPE]`). |
| **Router / View registration** (`aiohttp.web.RouteTableDef`, `aiohttp.web.UrlDispatcher`) | Use `METH_*` constants to declare allowed HTTP verbs for a route. |
| **HTTP parser** (`aiohttp.http_parser`) | Uses `*_ALL` sets to match incoming tokens irrespective of case. |
| **CIMultiDict** (`multidict.CIMultiDict`) | Relies on `istr` objects for case‑insensitive keys; header constants are supplied as `istr` to guarantee correct type. |
| **Utilities** (`aiohttp.helpers`, `aiohttp.web_exceptions`) | Reference header constants for generating standard error responses (e.g., `WWW-Authenticate`). |

No other module **imports from** `hdrs.py` in a circular fashion; it is a leaf node providing data only.

### 3.3 Architectural Placement  

```
aiohttp/
├─ hdrs.py                <-- canonical HTTP vocabulary (this file)
├─ http_parser.py         <-- low‑level parsing; uses _ALL sets
├─ web/
│   ├─ request.py         <-- accesses header constants
│   ├─ response.py        <-- accesses header constants
│   └─ router.py          <-- uses METH_* for routing
└─ ... (other utility modules)
```

Thus `hdrs.py` sits at the **foundation** of the HTTP layer—every higher‑level feature that works with HTTP messages depends on it.

---

## 4. Workflow Description  

1. **Module import** – When any aiohttp sub‑module imports `hdrs`, Python executes the file once, creating all constants.  
2. **Constant creation** –  
   * Simple strings (`METH_*`) are defined as `Final[str]`.  
   * Header names are wrapped with `istr` to provide case‑insensitive behaviour.  
3. **Permutation set generation** – For the three selected tokens (`HEAD`, `CONNECT`, `HOST`) the code:  
   * Calls `upper()` / `lower()` on the token → two tuples of characters.  
   * `zip` pairs each position’s upper & lower case.  
   * `itertools.product` produces every combination (2ⁿ for an *n*‑letter token).  
   * `map("".join, ...)` joins each tuple back into a string.  
   * `frozenset` stores the immutable collection.  
4. **Export** – All constants are part of the module’s public API (`__all__` is not defined, so everything is exported). Down‑stream modules simply import what they need, e.g., `from aiohttp import hdrs`.  
5. **Usage at runtime** –  
   * When parsing an incoming HTTP request line, the parser checks the method token against `METH_ALL`.  
   * When scanning header lines, the parser tests the field name against the appropriate `*_ALL` set (or directly against the `istr` objects for case‑insensitive dictionary insertion).  
   * Application code accesses header values through `hdrs` constants, guaranteeing spelling consistency.

---

## 5. Usage Examples  

```python
# Example: building a response with standard headers
from aiohttp import hdrs, web

async def handler(request):
    resp = web.Response(text="Hello, world!")
    # Use the constant to avoid a typo
    resp.headers[hdrs.CONTENT_TYPE] = "text/plain; charset=utf-8"
    # Add a cookie using the constant
    resp.headers[hdrs.SET_COOKIE] = "session=abcd1234; HttpOnly"
    return resp
```

```python
# Example: checking the request method in a middleware
from aiohttp import hdrs

@web.middleware
async def method_logger(request, handler):
    if request.method == hdrs.METH_POST:
        print("POST request received")
    return await handler(request)
```

```python
# Example: low‑level parsing (internal use)
from aiohttp import hdrs

def is_valid_method(token: str) -> bool:
    """Return True if *token* is a known HTTP method."""
    return token.upper() in hdrs.METH_ALL
```

---

## 6. Notes for Developers  

| Topic | Guidance / Gotchas |
|-------|--------------------|
| **Immutability** | All constants are declared with `typing.Final`. Do **not** reassign them at runtime; doing so defeats static analysis and may break code that expects identity equality (`is`). |
| **Case‑insensitivity** | Header name constants are `multidict.istr`. When interacting with plain `dict` objects, you must wrap the key with `istr` **or** use `CIMultiDict`. Mixing plain strings and `istr` objects can lead to surprising duplicate keys. |
| **Permutation sets** | Only three tokens have pre‑computed case permutations. All other header names rely on the `istr` implementation for case‑insensitive matching; there is **no** `*_ALL` set for them. Adding more sets should be justified (performance vs. memory). |
| **Extending the list** | If a new RFC introduces a header, add it here **as an `istr`** and update the parser if you need a case‑permutation set. After modifications, run `./tools/gen.py` as the file header instructs, to keep the generated parser in sync. |
| **Performance** | `frozenset` lookup is O(1). The permutation sets are tiny (e.g., `HEAD` → 16 entries), so the memory impact is negligible. |
| **Testing** | The constants are exercised indirectly through IO tests (request/response handling). When adding new constants, ensure that existing tests covering header parsing still pass. |
| **Documentation** | Because the module contains no functions, the public API is “the set of constants”. When documenting other modules, reference the exact constant name (`hdrs.AUTHORIZATION`) rather than the raw string (“Authorization”). |
| **Compatibility** | `hdrs.py` mirrors the HTTP/1.1 and HTTP/2 specifications supported by aiohttp. Do not use it to store HTTP/3‑specific pseudo‑headers (e.g., `:method`); those belong in a different module. |

--- 

*End of documentation.*