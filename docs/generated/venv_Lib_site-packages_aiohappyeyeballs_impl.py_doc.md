# `aiohappyeyeballs.impl` – Core Connection‑Establishment Logic  

---

## 1. Module Purpose  

### What the file is responsible for  
`aiohappyeyeballs.impl` implements the **low‑level, asyncio‑compatible logic** that establishes a TCP connection given a list of address‑info tuples (the result of `socket.getaddrinfo`).  
It provides:

* **`start_connection`** – the public coroutine that callers use to obtain a ready‑to‑use `socket.socket` object.  
* Helper utilities that perform a **single‑socket connect**, optionally **binding to a local address**, **interleaving address families**, and **running the “Happy Eyeballs” algorithm** (RFC 8305) to race IPv4/IPv6 attempts with a configurable delay.  

### Why it exists in the project  
`aiohappyeyeballs` is a small, pure‑Python implementation of the Happy Eyeballs algorithm used by modern browsers and networking libraries to reduce connection latency on dual‑stack hosts.  
The *impl* module isolates the **algorithmic core** from any transport‑specific glue code (e.g. `aiohappyeyeballs.protocol`) so it can be reused by:

* `loop.create_connection` wrappers  
* Custom networking stacks (e.g. `uvloop`)  

Having a dedicated implementation allows the package to:

* Keep the public API minimal (only `start_connection`).  
* Offer fine‑grained unit‑testing of the algorithm itself.  
* Provide a clear separation between **connection acquisition** and **protocol handling**.

---

## 2. Key Components  

### 2.1 `async def start_connection(...) -> socket.socket`  

| Parameter | Type | Meaning |
|-----------|------|---------|
| `addr_infos` | `Sequence[AddrInfoType]` | List of address‑info tuples (`family, type, proto, canonname, sockaddr`) for the *remote* endpoint. |
| `local_addr_infos` (kw‑only) | `Optional[Sequence[AddrInfoType]]` | Optional list of address‑info tuples for *local* bind addresses (e.g., `bind` before `connect`). |
| `happy_eyeballs_delay` (kw‑only) | `Optional[float]` | Delay in seconds before launching the second address family in the Happy‑Eyeballs race. If `None`, no race is performed. |
| `interleave` (kw‑only) | `Optional[int]` | When set, the remote address list is reordered to interleave families (default `None`). |
| `loop` (kw‑only) | `Optional[asyncio.AbstractEventLoop]` | Event‑loop to use; defaults to `asyncio.get_running_loop()`. |
| `socket_factory` (kw‑only) | `Optional[SocketFactoryType]` | Callable that receives an `AddrInfoType` and returns a pre‑configured `socket.socket`. Allows injection of custom socket subclasses (e.g., SSL sockets). |

#### What it does  
* Normalises the loop.  
* If Happy‑Eyeballs is requested **and** `interleave` is not supplied, defaults to interleaving by family (`interleave = 1`).  
* Optionally reorders the address list via `_interleave_addrinfos`.  
* **Two execution paths**:  
  * **No Happy Eyeballs** – iterate sequentially over `addr_infos` and try `_connect_sock` until one succeeds.  
  * **Happy Eyeballs** – launch a *staggered race* using `aiohappyeyeballs._staggered.staggered_race`, which starts the first connect task immediately, then starts the next after `happy_eyeballs_delay` seconds.  
* Collects **all exceptions** raised by the individual attempts. If none succeed, raises a combined exception that aggregates messages and tries to preserve the original `errno` when possible.  

#### Public API exposed  
Only `start_connection`.  All other functions are internal helpers.

---

### 2.2 `async def _connect_sock(...) -> socket.socket`  

| Parameter | Type | Meaning |
|-----------|------|---------|
| `loop` | `asyncio.AbstractEventLoop` | Event loop on which to perform the non‑blocking `sock_connect`. |
| `exceptions` | `List[List[Union[OSError, RuntimeError]]]` | Outer list is shared by `start_connection`; each call appends its own inner list of caught exceptions. |
| `addr_info` | `AddrInfoType` | A single address‑info tuple for the remote endpoint. |
| `local_addr_infos` (kw‑only) | `Optional[Sequence[AddrInfoType]]` | Local bind‑address candidates; may be `None`. |
| `open_sockets` (kw‑only) | `Optional[Set[socket.socket]]` | If supplied, the newly created socket is added to the set; useful for cleaning up “runner‑up” sockets when using Happy Eyeballs. |
| `socket_factory` (kw‑only) | `Optional[SocketFactoryType]` | Same purpose as in `start_connection`. |

#### What it does  

1. **Create the socket** – either via `socket_factory` or directly with `socket.socket`.  
2. **Add to `open_sockets`** (if provided) so the caller can later close any unused sockets.  
3. **Set non‑blocking mode** (`sock.setblocking(False)`).  
4. **Bind to a local address** (if `local_addr_infos` supplied):  
   * Iterate over candidate local addresses of the **same family**.  
   * On the first successful `bind`, break.  
   * If all attempts fail, raise the first captured `OSError` (or a generic message).  
5. **Connect** – `await loop.sock_connect(sock, address)`.  
6. **Return the connected socket** on success.  

On any exception (`OSError` or `RuntimeError`), the function:

* Records the exception in its private `my_exceptions` list (which is also stored in the shared `exceptions` container).  
* Removes the socket from `open_sockets` and closes it.  
* Re‑raises the exception so the caller can aggregate it.

---

### 2.3 `def _interleave_addrinfos(addrinfos, first_address_family_count=1) -> List[AddrInfoType]`  

| Parameter | Type | Meaning |
|-----------|------|---------|
| `addrinfos` | `Sequence[AddrInfoType]` | Original list of address‑info tuples (usually the result of `socket.getaddrinfo`). |
| `first_address_family_count` | `int` (default = 1) | Number of entries from the **first** address family to keep at the front before interleaving. |

#### What it does  

* **Group** the tuples by their `family` (IPv4, IPv6, etc.) while preserving original order using an `OrderedDict`.  
* If `first_address_family_count > 1`, keep that many entries from the first family at the very beginning.  
* **Interleave** the remaining groups using `itertools.zip_longest` (e.g., `IPv6, IPv4, IPv6, IPv4 …`).  
* **Flatten** the result, dropping `None` placeholders introduced by `zip_longest`.  

The function is a pure transformation; it does *not* perform any network I/O.

---

## 3. Dependencies & Relationships  

### Imports  

| Module | Reason |
|--------|--------|
| `asyncio` | Event‑loop handling, `sock_connect`. |
| `collections` | `OrderedDict` for family grouping. |
| `contextlib` | `suppress` to silently ignore close errors. |
| `functools` | `partial` to build the coroutine factories for the staggered race. |
| `itertools` | `zip_longest` for address interleaving. |
| `socket` | Core socket primitives (`socket`, families, types). |
| `typing` | Type hints (`List`, `Optional`, `Sequence`, `Set`, `Union`). |
| `._staggered` | Provides `staggered_race`, the orchestrator of the Happy‑Eyeballs race. |
| `types` (local) | `AddrInfoType`, `SocketFactoryType` – shared type definitions. |

### Interaction with other project components  

* **Depends on**  
  * `aiohappyeyeballs._staggered` – Implements the timer‑based race used when Happy Eyeballs is enabled.  
  * `aiohappyeyeballs.types` – Centralised type aliases for clarity.  

* **Potential dependents** (not in this file but logically)  
  * High‑level connection helpers that expose a simple API such as `aiohappyeyeballs.connect(host, port, ...)`.  
  * Transport factories that need a pre‑connected socket before handing it to a protocol implementation (`loop.create_connection`).  

* **Architectural placement**  
  * **Core / Engine**: This module lives in the *engine* layer – it knows nothing about higher‑level protocols or HTTP semantics; it only knows sockets and asyncio.  
  * It is **stateless** (except for the transient `exceptions` collection) and therefore safe to import and reuse across the application.

---

## 4. Workflow Description  

1. **Entry Point – `start_connection`**  
   * Resolve the running event loop.  
   * Detect whether there is a single remote address (`single_addr_info`).  
   * If Happy Eyeballs is requested **and** `interleave` is omitted, set `interleave = 1` (default interleaving by family).  
   * If `interleave` is truthy **and** there are multiple addresses, reorder the list with `_interleave_addrinfos`.  

2. **Connection Strategy**  
   * **No Happy Eyeballs (or single address)** → sequential attempt:  
     * Loop over each address, call `_connect_sock`.  
     * Break on first success, otherwise swallow the exception and continue.  

   * **Happy Eyeballs** → staggered race:  
     * Build a generator of **partial functions** that capture the current address and all required arguments for `_connect_sock`.  
     * Pass the generator and the configured delay to `_staggered.staggered_race`.  
     * `staggered_race` returns the winning socket plus the task metadata.  

3. **Cleanup of “Runner‑up” sockets** (Happy Eyeballs only)  
   * `open_sockets` set tracks every socket created by `_connect_sock`.  
   * After the race finishes, iterate over `open_sockets` and close any that are not the winner.  

4. **Error Aggregation**  
   * If **no socket** succeeded, flatten the `exceptions` list (list‑of‑list).  
   * Raise:  
     * The sole exception (if only one).  
     * A combined exception with a concatenated message if many.  
     * Preserve `errno` when all are `OSError` with the same `errno`.  
     * Prefer `OSError` over `RuntimeError` for compatibility.  

5. **Return** the successfully connected `socket.socket` to the caller.

---

## 5. Usage Examples  

```python
import asyncio
import socket
from aiohappyeyeballs.impl import start_connection

async def main():
    # Resolve remote addresses (IPv4 and IPv6) for example.com:443
    addr_infos = socket.getaddrinfo(
        "example.com", 443, type=socket.SOCK_STREAM
    )

    # Optionally resolve local bind addresses (e.g., specific source IP)
    # local_addr_infos = socket.getaddrinfo("192.168.1.100", 0, type=socket.SOCK_STREAM)

    # Perform a Happy‑Eyeballs connection with a 0.250 s delay between families
    sock = await start_connection(
        addr_infos,
        # local_addr_infos=local_addr_infos,
        happy_eyeballs_delay=0.250,
        interleave=1,               # interleave IPv6/IPv4
    )

    # Use the socket with asyncio's transports
    loop = asyncio.get_running_loop()
    transport, protocol = await loop.create_connection(
        lambda: MyProtocol(),
        sock=sock,
    )
    # … use transport / protocol …

asyncio.run(main())
```

*The example mirrors the docstring in `start_connection` and demonstrates:*

* Resolving remote addresses with `socket.getaddrinfo`.  
* Enabling Happy Eyeballs with a configurable delay.  
* Passing the resulting socket to `loop.create_connection`.

---

## 6. Notes for Developers  

| Topic | Details |
|-------|---------|
| **Happy Eyeballs algorithm** | Implemented via `_staggered.staggered_race`. The delay is the “fallback delay” (RFC 8305) – typical values are 0.25 s. |
| **Interleaving** | Useful when the DNS resolver returns many of the same family consecutively (e.g., several IPv6). `interleave` works by rearranging the address list before the sequential or staggered attempts. |
| **Exception handling** | All exceptions from each connection attempt are stored in a nested list (`exceptions`). The final aggregation tries to preserve the most meaningful error (`errno` propagation). Be aware that `RuntimeError` can be raised by **uvloop** instead of `OSError`. |
| **`socket_factory`** | Allows injection of custom socket subclasses (e.g., SSL‑wrapped sockets, SOCKS proxies). The factory receives the exact `AddrInfoType` tuple it would otherwise use to create a raw socket. |
| **Resource cleanup** | When Happy Eyeballs is used, the *open_sockets* set ensures that any socket created by a losing task is closed promptly, preventing file‑descriptor leaks. The cleanup runs even if the race is cancelled. |
| **Thread‑safety** | The module assumes a **single event loop** per coroutine execution. Sharing the `open_sockets` set across loops is unsafe. |
| **IPv4/IPv6 families** | `family` is an integer (`socket.AF_INET`, `socket.AF_INET6`, …). The interleaving logic groups by this integer, not by string name. |
| **Local bind support** | When `local_addr_infos` is supplied, only addresses with the **same family** as the remote address are tried. The first successful bind is used; failures are recorded as part of the per‑address exception list. |
| **Compatibility** | Works with the standard library `asyncio` event loop and with third‑party loops that implement `sock_connect` (e.g., `uvloop`). |
| **Future extensions** | If additional address families (e.g., `AF_UNIX`) need to be supported, the interleaving function already handles arbitrary integer families, but callers must supply appropriate `socket_factory` logic for non‑TCP sockets. |

--- 

*End of documentation for `aiohappyeyeballs.impl`.*