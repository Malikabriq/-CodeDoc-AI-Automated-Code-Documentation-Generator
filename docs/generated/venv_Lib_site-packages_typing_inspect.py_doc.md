# `typing_inspect.py` – Runtime Inspection Helpers for the **typing** Module  

---

## 1. Module Purpose  

| Aspect | Description |
|--------|-------------|
| **Responsibility** | Provides a **stable, version‑tolerant API** for examining objects from the standard `typing` (and `typing_extensions`) module at **runtime**. It abstracts over the many implementation details that differ between Python 2.7, Python 3.5‑3.6 (legacy typing), and the modern “PEP 560” era (≥ 3.7). |
| **Why it exists** | `typing`’s internal representation (e.g., `__origin__`, `__args__`, `_GenericAlias`, etc.) changes across Python releases. Directly accessing those attributes makes code fragile. `typing_inspect` centralises the logic so other parts of the project (type‑checking utilities, generic‑aware serializers, etc.) can rely on a **single source of truth** without having to duplicate version‑specific hacks. |
| **Scope** | The module is **purely introspection‑oriented** – it does **not** define new typing constructs, nor does it modify any existing typing objects. All public functions are read‑only helpers. |

---

## 2. Key Components  

Below each public helper is described together with its signature, return type, and a concise overview of the internal algorithm.

### Constants & Feature Flags  

| Name | Meaning |
|------|---------|
| `NEW_TYPING` | `True` for Python ≥ 3.7 (PEP 560). Determines which code‑paths are used. |
| `WITH_FINAL`, `WITH_LITERAL`, `WITH_CLASSVAR`, `WITH_NEWTYPE` | Feature‑presence flags that become `False` when the underlying typing implementation does not expose the corresponding construct (e.g., on Python 2.7). |
| `LEGACY_TYPING` | `True` for the very old typing module (≤ 3.5.3). Enables a different code‑path for many helpers. |
| `typingGenericAlias` | Tuple of concrete generic‑alias types used by the modern typing implementation (`_GenericAlias`, `_SpecialGenericAlias`, `types.GenericAlias`). |
| `LITERALS` | Set containing all literal marker types (`Literal` from `typing` and/or `typing_extensions`). |

### Helper Functions  

| Function | Description | Signature & Return |
|----------|-------------|--------------------|
| **`_gorg(cls)`** | Compatibility shim for legacy `GenericMeta` objects. Walks the `__origin__` chain to obtain the *origin generic* (the class that actually implements the generic). | `def _gorg(cls: GenericMeta) -> type` |
| **`is_generic_type(tp)`** | Returns `True` if *tp* is a *generic* (e.g., `List[int]`, `Iterable`, or a subclass of `typing.Generic`). Excludes special constructs like `Union`, `Tuple`, `Callable`, `ClassVar`. | `def is_generic_type(tp) -> bool` |
| **`is_callable_type(tp)`** | Detects **generic callables**, i.e. `typing.Callable` or any subclass that is also a `collections.abc.Callable`. | `def is_callable_type(tp) -> bool` |
| **`is_tuple_type(tp)`** | Detects **generic tuples** (`typing.Tuple` and subclasses). | `def is_tuple_type(tp) -> bool` |
| **`is_optional_type(tp)`** | True when *tp* is `type(None)` **or** a direct/indirect `Union` that contains `None`. Works recursively but does **not** inspect `TypeVar` bounds. | `def is_optional_type(tp) -> bool` |
| **`is_final_type(tp)`** | True when *tp* is the `typing.Final` marker (or a parametrised `Final[T]`). | `def is_final_type(tp) -> bool` |
| **`is_union_type(tp)`** | Detects any union representation: `typing.Union`, the PEP 604 `X | Y` syntax (`types.UnionType`), or the legacy `_Union` implementation. | `def is_union_type(tp) -> bool` |
| **`is_literal_type(tp)`** | True for `typing.Literal` (including `typing_extensions.Literal`) or a parametrised literal (`Literal[1, "a"]`). | `def is_literal_type(tp) -> bool` |
| **`is_typevar(tp)`** | Simple identity test – returns `True` only for objects created by `typing.TypeVar`. | `def is_typevar(tp) -> bool` |
| **`is_classvar(tp)`** | Detects the `ClassVar` construct (both modern and legacy implementations). | `def is_classvar(tp) -> bool` |
| **`is_new_type(tp)`** | Determines whether *tp* is a `typing.NewType` (or the `typing_extensions` version). Handles the quirky implementation details that changed after Python 3.10. | `def is_new_type(tp) -> bool` |
| **`is_forward_ref(tp)`** | Returns `True` if *tp* is an instance of `typing.ForwardRef` (legacy: `_ForwardRef`). | `def is_forward_ref(tp) -> bool` |
| **`get_last_origin(tp)`** *(legacy only)* | Walks the `__origin__` chain of a multiply‑subscripted type and returns the **deepest** origin. Raises on modern typing. | `def get_last_origin(tp) -> Optional[type]` |
| **`get_origin(tp)`** | Returns the *unsubscripted* base of a typing construct (e.g., `list` for `List[int]`, `Union` for `Union[int, str]`). Returns `None` for unsupported objects. | `def get_origin(tp) -> Optional[type]` |
| **`get_parameters(tp)`** | Retrieves **type variables** declared by a parametrisable type (generics, unions, tuples, callables). Returns a tuple ordered lexicographically. | `def get_parameters(tp) -> Tuple[TypeVar, ...]` |
| **`get_last_args(tp)`** *(legacy only)* | Similar to `get_last_origin` but returns the **arguments** of the deepest subscripted layer. | `def get_last_args(tp) -> Tuple[Any, ...]` |
| **`_eval_args(args)`** | Internal helper used by `get_args` for the legacy implementation. Recursively evaluates nested tuples that represent callable signatures. | `def _eval_args(args: Tuple) -> Tuple` |
| **`get_args(tp, evaluate=None)`** | Returns the **type arguments** of a typing construct, with all substitutions applied when `evaluate=True` (or automatically on Python ≥ 3.7). For legacy typing the default yields the *raw* substitution tree; if `evaluate=True` the tree is collapsed to concrete types. | `def get_args(tp, evaluate: Optional[bool]=None) -> Tuple[Any, ...]` |
| **`get_bound(tp)`** | For a `TypeVar`, returns its **upper bound** (`None` if absent). Raises `TypeError` for non‑`TypeVar`. | `def get_bound(tp) -> Optional[type]` |
| **`get_constraints(tp)`** | Returns a tuple of **constraints** from a `TypeVar`. Raises `TypeError` for non‑`TypeVar`. | `def get_constraints(tp) -> Tuple[type, ...]` |
| **`get_generic_type(obj)`** | Retrieves the **generic class** used to instantiate `obj` (`obj.__orig_class__` if present) else falls back to `type(obj)`. | `def get_generic_type(obj) -> type` |
| **`get_generic_bases(tp)`** | Returns the **original generic base classes** (`__orig_bases__`) of a class, or an empty tuple when not available. | `def get_generic_bases(tp) -> Tuple[type, ...]` |
| **`typed_dict_keys(td)`** | If *td* is a `TypedDict` class (from either `typing` or `typing_extensions`), returns a *copy* of its field‑type mapping; otherwise returns `None`. | `def typed_dict_keys(td) -> Optional[Dict[str, Any]]` |
| **`get_forward_arg(fr)`** | If *fr* is a `ForwardRef`, returns the underlying string; otherwise `None`. | `def get_forward_arg(fr) -> Optional[str]` |

#### Back‑ported Private Helpers (used only by legacy branches)

| Helper | Purpose |
|--------|---------|
| `_replace_arg(arg, tvars, args)` | Substitute a `TypeVar` with a concrete type inside a legacy typing tree. |
| `_remove_dups_flatten(parameters)` | Normalise a list of union arguments – deduplicate, flatten nested unions, and drop subclasses that are subsumed. |
| `_subs_tree(cls, tvars=None, args=None)` | Generic implementation of the substitution tree for legacy generic types. |
| `_union_subs_tree(tp, tvars=None, args=None)` | Compute the substitution tree for legacy `Union`. |
| `_generic_subs_tree(tp, tvars=None, args=None)` | Compute the substitution tree for legacy generic classes. |
| `_tuple_subs_tree(tp, tvars=None, args=None)` | Compute the substitution tree for legacy `Tuple`. |
| `_has_type_var(t)`, `_union_has_type_var`, `_tuple_has_type_var`, `_callable_has_type_var`, `_generic_has_type_var` | Recursive checks used by the back‑ported substitution logic to detect the presence of type variables. |

---

## 3. Dependencies & Relationships  

### Imports  

| Module | Used For |
|--------|----------|
| `sys`, `types` | Version checks, detection of `types.UnionType` (PEP 604). |
| `typing` | Core typing classes (`Generic`, `Callable`, `Union`, `TypeVar`, `ClassVar`, `Tuple`, `_GenericAlias`, `ForwardRef`, `NewType`). |
| `typing_extensions` | Back‑port of newer constructs (`Final`, `Literal`, `_TypedDictMeta`). |
| `mypy_extensions._TypedDictMeta` | Access to the mypy‑specific `TypedDict` metaclass. |
| Conditional imports of `_TypedDictMeta` from `typing_extensions` or `typing` based on Python version. |
| `collections.abc` (only on modern Python) | To recognise `collections.abc.Callable`. |

### Interaction with the Rest of the Project  

* **Consumers** – Any module needing reliable information about typing objects can import the public helpers (`is_generic_type`, `get_origin`, `get_args`, etc.). Typical consumers include:  
  * Runtime type‑checking utilities.  
  * Serialization frameworks that need to resolve generic element types.  
  * Code generation tools that reflect on `TypedDict` structures.  

* **Providers** – This file does **not** depend on any internal project modules; its only dependencies are the standard library and the external `typing_extensions` / `mypy_extensions` packages.

* **Architectural Placement** – It lives under the virtual‑environment's `site-packages` because it is a third‑party library (`typing_inspect`). In the project’s dependency graph it sits **below** any custom runtime‑type utilities and **above** user code that consumes its API.

---

## 4. Workflow Description  

Below is a **high‑level call flow** that explains how the module determines the nature of a typing object:

1. **Module Load**  
   * Detect Python version → set `NEW_TYPING`, `LEGACY_TYPING`, etc.  
   * Import the appropriate `TypedDict` meta‑classes (`_TypedDictMeta_Mypy`, `_TypedDictMeta_TE`).  
   * Build `typingGenericAlias` tuple for modern generic alias detection.

2. **Feature‑Flag Determination**  
   * Try importing `Final`, `Literal`, `NewType` from either `typing_extensions` or `typing`; set `WITH_*` flags accordingly.

3. **Public Helper Execution** (example: `is_generic_type`)  

   ```text
   is_generic_type(tp)
   ├─ If NEW_TYPING:
   │   ├─ Is `tp` a subclass of `typing.Generic`? → True
   │   └─ Is `tp` an instance of a known generic alias and its origin not a special construct? → True
   └─ Else (legacy):
       ├─ Is `tp` an instance of `GenericMeta`?
       └─ Exclude CallableMeta / TupleMeta
   ```

4. **Origin / Argument Retrieval** (`get_origin`, `get_args`)  

   * **Modern path** (`NEW_TYPING`):  
     * If `tp` is a known generic alias → return its `__origin__` (except `ClassVar`).  
     * Union / Callable / Tuple are handled via `__origin__` inspection.  
   * **Legacy path** (`LEGACY_TYPING`):  
     * Build a *substitution tree* (`_subs_tree`) that represents how type variables propagate through nested generic constructs.  
     * If `evaluate=True`, call `_eval_args` to collapse the tree into concrete arguments.  

5. **TypedDict Support** (`typed_dict_keys`)  

   * Detects the metaclass (`_TypedDictMeta_Mypy` or `_TypedDictMeta_TE`).  
   * Returns a shallow copy of the class’s `__annotations__` dict.

6. **Forward References** (`get_forward_arg`)  

   * Simple attribute lookup (`__forward_arg__`) after confirming the object is a `ForwardRef`.

All helpers are **pure functions** – they never mutate their arguments or any global state.

---

## 5. Usage Examples  

> The following snippets illustrate typical use‑cases. They rely only on the public API exported by `typing_inspect`.

```python
from typing import List, Union, Callable, Tuple, TypeVar, NewType, Final
import typing_inspect as ti

T = TypeVar('T')

# 1. Detect generic vs special typing constructs
assert ti.is_generic_type(List[int])          # True
assert not ti.is_generic_type(Union[int, str])  # False
assert ti.is_callable_type(Callable[[int], str])  # True
assert ti.is_tuple_type(Tuple[int, str])     # True

# 2. Extract origin and arguments
origin = ti.get_origin(List[int])            # <class 'list'>
args   = ti.get_args(List[int])              # (int,)

# 3. Optional detection (including nested unions)
opt_tp = Union[int, None]
assert ti.is_optional_type(opt_tp)           # True

# 4. NewType detection (works on both typing & typing_extensions)
UserId = NewType('UserId', int)
assert ti.is_new_type(UserId)                # True

# 5. TypedDict field inspection
from typing import TypedDict

class Point(TypedDict):
    x: int
    y: int

fields = ti.typed_dict_keys(Point)           # {'x': int, 'y': int}
```

---

## 6. Notes for Developers  

| Concern | Details & Gotchas |
|---------|-------------------|
| **Version Fragmentation** | The module contains three distinct execution branches (`NEW_TYPING`, `LEGACY_TYPING`, and the Python 2.7 fallback). When extending the API, remember to add the corresponding logic for each branch, or explicitly raise `NotImplementedError` for unsupported versions. |
| **Mutable Global Flags** | `WITH_FINAL`, `WITH_LITERAL`, etc., are set at import time based on what can be imported. Changing them later will **not** affect the behaviour of already defined helpers. |
| **`get_args` Evaluation Cost** | When `evaluate=True` (or on Python ≥ 3.7 where it is forced), the function may recursively substitute type variables, potentially **exponential** in pathological cases. Use it sparingly on very large, deeply nested type structures. |
| **ForwardRef Compatibility** | In legacy typing, `ForwardRef` is called `_ForwardRef`. The helper abstracts this difference, but note that the internal representation (`__forward_arg__`) is **private** and may change in future Python releases. |
| **TypedDict Metaclass Detection** | The module supports both mypy’s custom metaclass (`_TypedDictMeta`) and the one from `typing_extensions`. If a third‑party library introduces a new implementation, you will need to extend the `isinstance` check in `typed_dict_keys`. |
| **Union vs PEP 604** | The function `is_union_type` recognises two representations: the classic `typing.Union` and the newer `types.UnionType` (generated by the `|` operator). When writing code that expects *only* one representation, guard with `isinstance(tp, types.UnionType)` after confirming the attribute exists. |
| **Subclass Detection** | Functions like `is_callable_type` and `is_tuple_type` also return `True` for *subclasses* of the respective generic. If an exact‑type check is required, compare `get_origin(tp)` directly (`ti.get_origin(tp) is collections.abc.Callable`). |
| **Legacy Helper Visibility** | Functions prefixed with `_` (e.g., `_gorg`, `_subs_tree`) are **private** but are used by the public helpers for legacy support. They are deliberately left in the module to avoid import‑time overhead for the modern path. Do not rely on them in external code. |
| **Testing Strategy** | Unit tests should run on a **matrix of Python versions** (2.7, 3.5, 3.6, 3.7+, 3.9, 3.10) to verify each branch behaves as expected. Mocking `sys.version_info` is useful for exercising conditional import logic. |
| **Future Python releases** | The module already contains a guard for Python ≥ 3.9.2 concerning `TypedDict`. When new typing features are added (e.g., `ParamSpec`), follow the existing pattern: import from `typing_extensions` first, fall back to `typing`, and update the feature flags accordingly. |

--- 

**End of documentation**.