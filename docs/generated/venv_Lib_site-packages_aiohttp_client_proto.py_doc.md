# aiohttp.client_proto – `ResponseHandler`

## 1. Module Purpose
**File:** `aiohttp/client_proto.py`

The module implements the *client‑side* low‑level protocol machinery that turns raw bytes received from a socket into high‑level HTTP response objects (`RawResponseMessage`) together with a `StreamReader` that yields the response body.  

- **Responsibility** – Receive data from the transport, feed it to an `HttpResponseParser`, surface completed messages via a `DataQueue`, manage read‑time‑outs, and coordinate graceful shutdown/abort of the underlying connection.  
- **Why it exists** – aiohttp separates the network I/O (protocol) from the user‑facing API (`ClientSession`, `ClientResponse`). The `ResponseHandler` is the bridge that adapts the asyncio protocol interface (`BaseProtocol`) to the higher‑level streaming abstractions used by aiohttp’s client code.

---

## 2. Key Components

### 2.1 Class `ResponseHandler`
`ResponseHandler` inherits from two bases:

| Base | Purpose |
|------|---------|
| `BaseProtocol` | Implements the low‑level asyncio Protocol API (`data_received`, `connection_lost`, …) and supplies a transport field. |
| `DataQueue[Tuple[RawResponseMessage, StreamReader]]` | An async queue that yields pairs *(response line/message, payload reader)* to the consumer (e.g. `ClientResponse`). |

#### Public API
| Name | Signature | Description |
|------|-----------|-------------|
| `closed` (property) | `-> Union[None, asyncio.Future[None]]` | Future that becomes resolved when the underlying connection is closed. Created lazily. |
| `upgraded` (property) | `-> bool` | Indicates whether the connection has been upgraded (e.g. to WebSocket). |
| `should_close` (property) | `-> bool` | Returns `True` if the protocol decides that the transport must be closed after the current response. |
| `force_close()` | `-> None` | Marks the handler as needing to close the transport as soon as possible. |
| `close()` | `-> None` | Gracefully close the transport, drop time‑outs, clear payload references. |
| `abort()` | `-> None` | Abort the transport (immediate termination), similar to `close` but uses `transport.abort()`. |
| `is_connected()` | `-> bool` | Returns `True` while a live transport is attached and not in the process of closing. |
| `connection_lost(exc)` | `-> None` | Called by asyncio when the underlying transport is lost. Translates low‑level exceptions into aiohttp‑specific ones, resolves the `closed` future, finalises parsers and payloads, and forces a shutdown. |
| `eof_received()` | `-> None` | Called when the peer sends EOF; currently only drops the read timeout. |
| `pause_reading()` / `resume_reading()` | `-> None` | Propagate pause/resume to the base protocol and manage the read‑timeout timer. |
| `set_exception(exc, exc_cause=_EXC_SENTINEL)` | `-> None` | Marks the protocol as failed, forces closure, cancels timeout, and propagates the exception to the underlying `DataQueue`. |
| `set_parser(parser, payload)` | `-> None` | Attach a *custom* payload parser (e.g. WebSocket) together with its payload queue, clear any pending tail data. |
| `set_response_params(*, timer=None, skip_payload=False, read_until_eof=False, auto_decompress=True, read_timeout=None, read_bufsize=2**16, timeout_ceil_threshold=5, max_line_size=8190, max_field_size=8190)` | `-> None` | Initialise the HTTP response parser (`HttpResponseParser`) with the supplied configuration. |
| `start_timeout()` | `-> None` | (Re)activate the read timeout timer. |
| `read_timeout` (property, getter / setter) | `Optional[float]` | Expose the configured read timeout. |
| `data_received(data: bytes)` | `-> None` | Core entry point from asyncio when new bytes arrive. It feeds data to either a custom payload parser or the HTTP parser, creates response/message tuples for the queue, and steers upgrades and tail handling. |
| `_drop_timeout()` / `_reschedule_timeout()` | `-> None` | Internal helpers to cancel or re‑schedule the read‑timeout handle. |
| `_on_read_timeout()` | `-> None` | Invoked when the read timeout expires; forces a `SocketTimeoutError` on the protocol and the payload reader. |

#### Important Instance Attributes (private)
| Attribute | Meaning |
|-----------|---------|
| `_should_close` | Flag that forces the transport to be closed after the current processing step. |
| `_payload` | The `StreamReader` that will deliver the response body for the *current* message. |
| `_skip_payload` | When `True`, the body is discarded (`EMPTY_PAYLOAD`). |
| `_payload_parser` | Optional custom parser (e.g. WebSocketReader) that consumes raw data directly. |
| `_timer` | Not used directly in this file – part of the broader timing infrastructure. |
| `_tail` | Buffer that holds data that could not yet be processed (e.g. when an upgrade occurs). |
| `_upgraded` | Set to `True` once the parser reports an upgrade (WebSocket, HTTP/2, …). |
| `_parser` | Instance of `HttpResponseParser` that knows how to split raw bytes into HTTP messages. |
| `_read_timeout` / `_read_timeout_handle` | Configured timeout in seconds and the asyncio `TimerHandle` that triggers `_on_read_timeout`. |
| `_timeout_ceil_threshold` | Upper bound used by the parser’s internal back‑off (propagated from `set_response_params`). |
| `_closed` | Lazy `Future` that signals connection closure to external waiters. |
| `_connection_lost_called` | Tracks whether `connection_lost` has already been invoked (used for lazy creation of `_closed`). |

---

### 2.2 Helper Functions (imported)

| Import | Purpose |
|--------|---------|
| `BaseProtocol` (`.base_protocol`) | Base class implementing the low‑level asyncio Protocol API. |
| Exception classes (`ClientConnectionError`, `ClientOSError`, `ClientPayloadError`, `ServerDisconnectedError`, `SocketTimeoutError`) (`.client_exceptions`) | Specific error types that `ResponseHandler` raises or translates to. |
| `_EXC_SENTINEL`, `EMPTY_BODY_STATUS_CODES`, `BaseTimerContext`, `set_exception`, `set_result` (`.helpers`) | Constants and small utilities used for error handling and parser configuration. |
| `HttpResponseParser`, `RawResponseMessage` (`.http`) | Parser that produces `RawResponseMessage` objects and determines upgrades. |
| `HttpProcessingError` (`.http_exceptions`) | Generic parsing‑level exception raised by `HttpResponseParser`. |
| `EMPTY_PAYLOAD`, `DataQueue`, `StreamReader` (`.streams`) | Core streaming abstractions. `EMPTY_PAYLOAD` a pre‑created empty `StreamReader`; `DataQueue` is the async queue used to expose messages. |

No other functions are defined in this file.

---

## 3. Dependencies & Relationships

### 3.1 Direct Imports
```python
import asyncio
from contextlib import suppress
from typing import Any, Optional, Tuple, Union

from .base_protocol import BaseProtocol
from .client_exceptions import (
    ClientConnectionError,
    ClientOSError,
    ClientPayloadError,
    ServerDisconnectedError,
    SocketTimeoutError,
)
from .helpers import (
    _EXC_SENTINEL,
    EMPTY_BODY_STATUS_CODES,
    BaseTimerContext,
    set_exception,
    set_result,
)
from .http import HttpResponseParser, RawResponseMessage
from .http_exceptions import HttpProcessingError
from .streams import EMPTY_PAYLOAD, DataQueue, StreamReader
```

### 3.2 Interaction with Other aiohttp Components

| Component | How `ResponseHandler` Uses It |
|-----------|------------------------------|
| `BaseProtocol` | Supplies low‑level transport handling (`connection_made`, `connection_lost`, pause/resume). |
| `HttpResponseParser` | Parses incoming bytes into `RawResponseMessage` objects and possible payload `StreamReader`s. |
| `DataQueue[Tuple[RawResponseMessage, StreamReader]]` | Acts as the public queue from which higher‑level client code (`ClientResponse`) pulls completed responses. |
| `StreamReader` | Represents the body payload; attached to the queue entry and used by callers to read the response content. |
| `Client*` exception classes | Translate transport‑level errors into the semantic API errors visible to client users. |
| `helpers.set_exception` / `helpers.set_result` | Utility wrappers that correctly attach a cause to a future. |
| `EMPTY_PAYLOAD` | Used when the response should have no body (e.g., status 204) to avoid allocating a new reader. |
| Custom payload parser (`_payload_parser`) | For protocols that switch away from HTTP (e.g., WebSocket), a different parser is attached and `ResponseHandler` forwards raw data directly to it. |

### 3.3 Logical Consumers (who depends on this module)

- **`aiohttp.client_reqrep`** – constructs a `ClientResponse` object that reads from the `ResponseHandler` queue.
- **`aiohttp.client`** – high‑level request/response orchestration creates a transport and assigns a `ResponseHandler` as its protocol.
- **WebSocket handling** – when an HTTP response signals an upgrade, a WebSocket reader replaces the normal parser; the upgrade path is coordinated by `ResponseHandler`.

Thus, `ResponseHandler` sits in the middle of the data‑flow: *socket → protocol → parser → queue → client API*.

---

## 4. Workflow Description

Below is a step‑by‑step outline of the life‑cycle of a `ResponseHandler` instance.

1. **Instantiation**
   ```python
   handler = ResponseHandler(loop)
   ```
   - Calls `BaseProtocol.__init__(loop)` and `DataQueue.__init__(loop)`.
   - All internal flags set to their defaults.

2. **Transport Assignment**
   - The asyncio event loop creates a transport (TCP, SSL) and calls `handler.connection_made(transport)`.  
   - `BaseProtocol` stores the transport; `ResponseHandler` does not override this step.

3. **Configuration**
   - The client code invokes `handler.set_response_params(...)` with the desired options (timeouts, buffer sizes, decompression, etc.).
   - Internally a new `HttpResponseParser` is created and stored in `handler._parser`.
   - If there is any pending `_tail` data (e.g., from a previous upgrade), `handler.data_received` is called immediately.

4. **Receiving Data**
   - The transport calls `handler.data_received(data)`.
   - **Timeout handling:** `_reschedule_timeout` is called to reset the read‑timer.
   - **Custom parser path:**  
     - If `_payload_parser` is set (WebSocket), data is delegated to it (`feed_data`). When EOF is reached, both parser and payload are cleared.
   - **Upgrade or not‑yet‑parsed path:**  
     - If the connection is already upgraded (`_upgraded`) **or** the HTTP parser is not available, the data is appended to `_tail` and processing stops until the appropriate parser is ready.
   - **Normal HTTP path:**  
     - `self._parser.feed_data(data)` returns a tuple *(messages, upgraded, tail)*.  
     - `messages` – a list of `(RawResponseMessage, StreamReader)` pairs.  
     - `upgraded` – a bool indicating an HTTP protocol upgrade (e.g., `101 Switching Protocols`).  
     - `tail` – any remaining bytes that belong after the last parsed message (e.g., part of the next response in a pipelined scenario).

5. **Queueing Parsed Messages**
   - For each `(message, payload)` produced:
     - `message.should_close` influences `_should_close`.
     - If the payload should be skipped or the status appears in `EMPTY_BODY_STATUS_CODES`, the handler enqueues `(message, EMPTY_PAYLOAD)`.
     - Otherwise, it enqueues `(message, payload)`.
   - The `feed_data` method (inherited from `DataQueue`) puts the tuple into the internal async queue, making it available to the client side.

6. **Payload Handling**
   - If the payload is not `EMPTY_PAYLOAD`, the payload’s `on_eof` callback is set to `_drop_timeout`. This ensures the read‑timeout is cancelled once the body finishes.
   - When the payload finishes (`payload.on_eof` fires), the timeout handle is cleared.

7. **Upgrade Continuation**
   - If `upgraded` is `True` and there is leftover `tail`, `data_received(tail)` is called recursively to feed the remaining data to the new protocol (e.g., WebSocket reader).

8. **Timeout Expiration**
   - When the read timeout fires (`_on_read_timeout`), a `SocketTimeoutError` is set on the protocol via `set_exception`. The payload (if present) receives the same exception.

9. **Connection Loss**
   - If the underlying transport is closed unexpectedly, asyncio calls `handler.connection_lost(exc)`.
   - The method:
     - Marks the connection as lost.
     - Resolves or rejects the `closed` future.
     - Feeds EOF to the payload parser (if any) and the HTTP parser.
     - Constructs appropriate high‑level exceptions (`ClientConnectionError`, `ClientOSError`, `ServerDisconnectedError`, `ClientPayloadError`) based on the original exception and parser state.
     - Forces the handler to close (`_should_close = True`).
     - Calls `super().connection_lost(reraised_exc)` to propagate to `BaseProtocol`.

10. **Graceful Close / Abort**
    - `close()` gracefully shuts down the transport and clears internal references.
    - `abort()` does the same but uses `transport.abort()` for an immediate termination (e.g., when a hard cancel is required).

---

## 5. Usage Examples

Below are *illustrative* snippets that show how the `ResponseHandler` is typically employed by higher‑level aiohttp code. The examples **do not** introduce new functionality beyond what is defined in the file.

### 5.1 Creating a handler and configuring it
```python
import asyncio
from aiohttp.client_proto import ResponseHandler

loop = asyncio.get_event_loop()
handler = ResponseHandler(loop)

handler.set_response_params(
    read_timeout=30.0,
    read_bufsize=65536,
    auto_decompress=True,
    skip_payload=False,
    read_until_eof=False,
)
```

### 5.2 Feeding data (as the transport would)
```python
# Simulate bytes received from a TCP socket
raw_http = b"HTTP/1.1 200 OK\r\nContent-Length: 5\r\n\r\nhello"
handler.data_received(raw_http)

# Retrieve the parsed response from the queue
message, payload_reader = await handler.get()
print(message.code)                     # 200
body = await payload_reader.read()      # b'hello'
```

### 5.3 Handling an upgrade (e.g., WebSocket)
```python
# Assume `ws_parser` and `ws_queue` are instances created elsewhere
handler.set_parser(ws_parser, ws_queue)

# Subsequent data received will be forwarded directly to the WebSocket parser
handler.data_received(b"some websocket frames...")
```

### 5.4 Observing connection closure
```python
# Wait until the transport has been closed (e.g., by the server or an error)
await handler.closed  # resolves when connection_lost has been processed
```

---

## 6. Notes for Developers

| Topic | Details / Gotchas |
|-------|--------------------|
| **Lazy `closed` Future** | The `closed` property creates a future **only** when first accessed and the connection has not yet been marked as lost. If `connection_lost` fires before any consumer asked for `closed`, the future remains `None`. Remember to check for `None` when awaiting closure. |
| **Timeout Management** | The read timeout is *reset* on every `data_received` and on `resume_reading`. If you pause reading for a prolonged period, the timeout will still fire unless you also pause the timer (not currently done). |
| **Upgrade Path** | When `upgraded` becomes `True`, the HTTP parser is no longer used. All subsequent bytes after the upgrade are stored in `_tail` until a custom parser (e.g., WebSocket) is attached via `set_parser`. Failure to attach a parser will cause data to be stuck in `_tail`. |
| **Exception Propagation** | `set_exception` always forces the handler to close (`_should_close = True`) and cancels any active timeout. It also propagates the exception to the underlying `DataQueue` via `BaseProtocol.set_exception`. This ensures that any awaiting consumer receives the error. |
| **Payload Completion** | The payload reader’s `on_eof` callback is wired to `_drop_timeout`. If a user consumes the payload but never reaches EOF (e.g., they abandon the stream), the timeout will remain active until the connection closes. |
| **`EMPTY_BODY_STATUS_CODES`** | Certain HTTP status codes (e.g., 204, 304) have no body. The handler checks `message.code` against this constant and substitutes `EMPTY_PAYLOAD` to avoid creating unnecessary `StreamReader` objects. |
| **Thread‑Safety** | All public methods are expected to be called from the event‑loop thread only. No internal locking is performed; calling them from other threads results in undefined behavior. |
| **Future Compatibility** | The module uses `BaseTimerContext` (imported from `.helpers`) for timing‐related configuration, but the current implementation only stores it; future extensions may use it for more sophisticated timeout back‑off. |
| **Error‑Handling Gaps** | In `connection_lost`, the code suppresses all exceptions when feeding EOF to `_payload_parser`. Ideally, such failures should be logged; a `FIXME` comment marks this as a known technical debt. |
| **Testing** | When unit‑testing, mock the transport and inject data through `data_received`. Verify that the queue receives the expected `(RawResponseMessage, StreamReader)` tuples and that the `closed` future resolves appropriately on simulated connection loss. |
| **Python Versions** | Type hints use `asyncio.Future[None]` (PEP‑484 generic) and other modern typing features; the file assumes at least Python 3.9+. |

---