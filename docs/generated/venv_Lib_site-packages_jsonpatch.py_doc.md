# `jsonpatch.py` – JSON‑Patch Implementation (RFC 6902)

## 1. Module Purpose  

| Aspect | Description |
|--------|-------------|
| **Responsibility** | Provides a pure‑Python implementation of *JSON Patch* (RFC 6902). It can **apply** a list of patch operations to a JSON‑compatible document, **generate** a patch by diffing two documents, and **serialize/deserialize** patches. |
| **Why it exists** | Applications that need to synchronise or transform JSON data (e.g., REST APIs, configuration management, data migration) often require a compact, atomic description of changes. This module supplies a battle‑tested, standards‑compliant engine that can be used directly or as a building block for higher‑level services. |

---

## 2. Key Components  

### 2.1 Exceptions  

| Class | Purpose | Public API |
|------|----------|------------|
| `JsonPatchException` | Base class for all errors raised by this module. | – |
| `InvalidJsonPatch` | Raised when a supplied patch (or a single operation) is malformed (missing required members, wrong types, etc.). | – |
| `JsonPatchConflict` | Raised when a *conflict* prevents an operation from being applied (e.g., removing a non‑existent key, inserting outside an array). | – |
| `JsonPatchTestFailed` | Raised when a `test` operation fails. Inherits from both `JsonPatchException` and `AssertionError` for test‑style handling. | – |

---

### 2.2 Helper Functions  

| Function | Description | Signature |
|----------|-------------|-----------|
| `multidict(ordered_pairs)` | Converts a list of *(key, value)* pairs that may contain duplicate keys into a mapping where duplicate keys become **lists** of values. Used as `object_pairs_hook` when loading JSON that may contain duplicate keys. | `multidict(ordered_pairs: List[Tuple[str, Any]]) -> Dict[str, Any]` |
| `_jsonloads` | Partial of `json.loads` that uses `multidict` as `object_pairs_hook`. Enables tolerant loading of JSON strings with duplicate object keys. | – |
| `apply_patch(doc, patch, in_place=False, pointer_cls=JsonPointer)` | Convenience wrapper that creates a `JsonPatch` instance (from a list or a JSON string) and applies it to `doc`. | `apply_patch(doc: Any, patch: Union[str, List[Dict]], in_place: bool=False, pointer_cls=JsonPointer) -> Any` |
| `make_patch(src, dst, pointer_cls=JsonPointer)` | Shortcut for `JsonPatch.from_diff(src, dst, pointer_cls)`. Returns a `JsonPatch` that transforms `src` into `dst`. | `make_patch(src: Any, dst: Any, pointer_cls=JsonPointer) -> JsonPatch` |
| `_path_join(path, key)` | Internal utility that joins a JSON‑Pointer *path* and a *key* safely, escaping `~` and `/` according to RFC 6901. | `_path_join(path: str, key: Any) -> str` |

---

### 2.3 Core Classes  

#### `PatchOperation` (abstract)  

*Represents a single JSON‑Patch operation (add, remove, replace, …).*  

| Attribute | Meaning |
|-----------|--------|
| `operation` | The raw dict that defines the operation (`{'op': ..., 'path': ..., ...}`) |
| `pointer_cls` | Class used for JSON‑Pointer handling (defaults to `jsonpointer.JsonPointer`). |
| `location` | Normalized string path (`/a/b`). |
| `pointer` | `JsonPointer` instance pointing to `location`. |

**Key methods / properties**  

| Method / Property | Behaviour |
|-------------------|-----------|
| `apply(obj)` | **Abstract** – concrete subclasses implement the actual mutation. |
| `path` (property) | Returns the parent path of the operation (`/a` for `/a/b`). |
| `key` (property) | Returns the final token of the pointer (numeric index if possible). |
| `key.setter` | Allows rewriting the final token (used by the diff‑builder when rearranging operations). |
| `__hash__`, `__eq__`, `__ne__` | Equality based on the underlying operation dict. |

---

#### Sub‑classes of `PatchOperation`  

| Class | RFC 6902 operation | Core Logic |
|-------|-------------------|------------|
| `RemoveOperation` | `remove` | Resolves the parent container (`to_last`) and deletes the target key/array index. Raises `JsonPatchConflict` on missing target. |
| `AddOperation` | `add` | Retrieves the `value` member; inserts into a mutable sequence (`append` or `insert`) or sets a mapping entry. Handles the special `-` token for appending to arrays. |
| `ReplaceOperation` | `replace` | Similar to `add` but **must** replace an existing entry; raises conflict if target does not exist. |
| `MoveOperation` | `move` | Reads the value from the `from` pointer, removes it via a temporary `RemoveOperation`, then adds it at the new location with a temporary `AddOperation`. Also checks for illegal moves (e.g., moving a node into its own descendant). |
| `CopyOperation` | `copy` | Deep‑copies a value from `from` pointer and adds it at `path`. |
| `TestOperation` | `test` | Retrieves the target value and compares it with the supplied `value`. If unequal, raises `JsonPatchTestFailed`. |
| `PatchOperation` itself does **not** expose a public API beyond what the concrete subclasses implement. |

All operation classes expose only the `apply(obj)` method; they are instantiated internally by `JsonPatch._get_operation`.

---

#### `JsonPatch`  

*Container for an ordered list of patch operations; the main public API of the module.*  

| Public attributes | Meaning |
|-------------------|--------|
| `json_dumper` | Static method (`json.dumps`) used by `to_string`. |
| `json_loader` | Static method (`_jsonloads`) used by `from_string`. |
| `operations` | **Read‑only** mapping from the operation name (`'add'`, `'remove'`, …) to the concrete class. |

| Key methods | Description |
|------------|-------------|
| `__init__(self, patch, pointer_cls=JsonPointer)` | Validates the supplied *patch* (sequence of dicts) and stores it. Validation includes ensuring each element is a mapping and that it contains a valid `'op'`. |
| `from_string(cls, patch_str, loads=None, pointer_cls=JsonPointer)` | Parses a JSON string into a Python list (using `json_loader`) and returns a `JsonPatch` instance. |
| `from_diff(cls, src, dst, optimization=True, dumps=None, pointer_cls=JsonPointer)` | **Diff engine** – creates a patch that turns `src` into `dst`. Internally builds a `DiffBuilder`, walks both structures, and returns the generated operations. |
| `to_string(self, dumps=None)` | Serialises the underlying patch list back to JSON. |
| `apply(self, obj, in_place=False)` | Applies the patch sequence to `obj`. If `in_place` is `False` (default) a deep copy of `obj` is made first. Returns the mutated document. |
| `_ops` (property) | Lazily converts the raw operation dicts into their concrete `PatchOperation` objects. |
| `_get_operation(self, operation)` | Internal factory that validates a single operation dict and returns the appropriate `PatchOperation` subclass instance. |

**Public API** – the three class methods (`from_string`, `from_diff`), the instance methods (`apply`, `to_string`), and the boolean/iteration semantics (`bool(patch)`, iteration over raw dicts) constitute the outward‑facing contract.

---

#### `DiffBuilder`  

*Internal helper that inspects two JSON‑compatible structures and emits the minimal set of operations.*  

| Constructor | Parameters |
|------------|------------|
| `DiffBuilder(src_doc, dst_doc, dumps=json.dumps, pointer_cls=JsonPointer)` | The source and destination documents. `dumps` is used for canonicalisation when comparing primitive values. |

**Main responsibilities**  

1. **Indexing** – Stores temporary maps (`index_storage`, `index_storage2`) to detect when a value that is removed from one place appears elsewhere (potential *move*).  
2. **Linked‑list of pending operations** – Maintains a doubly‑linked list (`self.__root`) that can be reordered, inserted, or removed while iterating. This permits detection of *replace* patterns (remove + add at same location → replace).  
3. **Recursive comparison** – `_compare_values`, `_compare_dicts`, `_compare_lists` walk the two structures, emitting `AddOperation`, `RemoveOperation`, `ReplaceOperation`, or delegating to more specific methods when nested containers are detected.  
4. **Operation optimisation** – When a value that was added elsewhere is later removed, the builder may coalesce them into a `MoveOperation`. Similarly, a `remove` followed by an `add` on the same path becomes a `ReplaceOperation`.  

**Public iterator** – `execute()` yields the final operations in the order they should be applied.

*The DiffBuilder is **not** part of the public module API; it is used exclusively by `JsonPatch.from_diff`.*

---

## 3. Dependencies & Relationships  

### 3.1 Imports  

| Module | Reason |
|--------|--------|
| `collections`, `collections.abc` | For abstract base classes (`MutableMapping`, `MutableSequence`, `Sequence`) and `defaultdict`. |
| `copy` | Deep‑copying values for the `copy` operation and for making a safe working copy in `JsonPatch.apply`. |
| `functools` | `partial` to create `_jsonloads`. |
| `json` | Serialisation / deserialisation of JSON strings and canonicalisation of primitive values during diffing. |
| `sys` | Detect Python version to adjust `basestring` handling. |
| `jsonpointer.JsonPointer`, `jsonpointer.JsonPointerException` | Core JSON‑Pointer mechanics (resolution, traversal, validation). |
| `types.MappingProxyType` (fallback to `dict`) | Immutable read‑only view of the `operations` mapping. |

### 3.2 Interaction with Other Modules  

| Direction | Module | Interaction |
|-----------|--------|-------------|
| **Uses** | `jsonpointer` | `JsonPatch` and all operation classes rely on `JsonPointer` for path resolution, parent navigation (`to_last`, `walk`), and containment checks. |
| **Provides** | Client code (any Python program) | Public functions (`apply_patch`, `make_patch`) and the `JsonPatch` class are intended for external consumption. |
| **Potential Consumers** | REST frameworks, configuration management tools, data‑synchronisation layers | They can import `apply_patch` or instantiate `JsonPatch` directly. |

### 3.3 Architectural Fit  

* `jsonpatch.py` sits at the **data‑transformation layer** of a project. It does not know anything about HTTP, databases, or persistence – it only manipulates in‑memory Python objects that map to JSON. This makes it reusable across any stack that needs JSON‑Patch support.

---

## 4. Workflow Description  

### 4.1 Applying a Patch (high‑level)

1. **User call** – `apply_patch(doc, patch, in_place=False)` (or `JsonPatch(patch).apply(doc)`).
2. **Patch preparation**  
   * If `patch` is a JSON string → `JsonPatch.from_string` parses it via `_jsonloads`.  
   * If `patch` is a Python list → a `JsonPatch` instance is built directly.  
   * Constructor validates each operation (`_get_operation`).  
3. **Document cloning** – unless `in_place=True`, a deep copy of `doc` is created.  
4. **Operation execution** – `_ops` property lazily converts each dict into a concrete `PatchOperation`.  
5. **Sequential apply** – each operation’s `apply` method mutates the document (or copy). Errors raise the appropriate exception, aborting the process.  
6. **Result** – the (possibly mutated) document is returned.

### 4.2 Generating a Patch (diff)

1. **User call** – `make_patch(src, dst)` or `JsonPatch.from_diff(src, dst)`.  
2. **DiffBuilder creation** – holds the two documents, a JSON‑dump function for canonical comparison, and a `JsonPointer` factory.  
3. **Recursive walk** – `_compare_values` decides whether to descend into dictionaries, lists, or treat primitives.  
4. **Operation collection** –  
   * `AddOperation` for new keys/elements.  
   * `RemoveOperation` for missing keys/elements.  
   * `ReplaceOperation` when a primitive/value changes.  
   * `MoveOperation` and `CopyOperation` are inferred when the same value appears elsewhere (detected via the index tables).  
5. **Optimization pass** – The linked list of pending ops is examined; a `remove` followed immediately by an `add` at the same location is collapsed into a `replace`.  
6. **Yield** – `execute()` walks the linked list, emitting the final concrete operation dicts in the correct order.  
7. **Patch object** – The list of dicts is handed back to `JsonPatch.__init__`, producing a ready‑to‑apply patch.

---

## 5. Usage Examples  

The module already contains doctest‑style examples; they are reproduced here for quick reference.

```python
>>> from jsonpatch import apply_patch, make_patch, JsonPatch
>>> doc = {'foo': 'bar'}

# --- Simple add ---
>>> patch = [{'op': 'add', 'path': '/baz', 'value': 'qux'}]
>>> new_doc = apply_patch(doc, patch)      # copy‑on‑apply
>>> new_doc
{'foo': 'bar', 'baz': 'qux'}

# --- In‑place modification ---
>>> apply_patch(doc, patch, in_place=True)
{'foo': 'bar', 'baz': 'qux'}
>>> doc
{'foo': 'bar', 'baz': 'qux'}

# --- Diff generation ---
>>> src = {'foo': 'bar', 'numbers': [1, 3, 4, 8]}
>>> dst = {'baz': 'qux', 'numbers': [1, 4, 7]}
>>> p = make_patch(src, dst)               # returns a JsonPatch instance
>>> patched = p.apply(src)
>>> patched == dst
True

# --- Using JsonPatch directly ---
>>> p2 = JsonPatch.from_string('[{"op":"replace","path":"/a","value":1}]')
>>> p2.apply({'a': 0})
{'a': 1}
```

---

## 6. Notes for Developers  

| Topic | Detail |
|-------|--------|
| **Duplicate JSON keys** | The custom `multidict` loader preserves duplicate keys by turning them into lists. This is required because the standard `json` module would drop duplicates. Be aware that downstream code may receive a list where a single value was expected. |
| **Pointer handling** | All operations rely on `JsonPointer.to_last` which returns a tuple `(parent, token)`. If the token cannot be resolved (missing key, out‑of‑range index) a `JsonPointerException` is raised and translated into a `JsonPatchConflict` (or `JsonPatchTestFailed` for `test`). |
| **Array `-` token** | In `AddOperation`, the special `-` path token means “append to the end of the array”. Only the `add` operation supports it; `replace`/`remove` treat `-` as invalid. |
| **Move vs. Copy** | `MoveOperation` physically removes the source before inserting at the destination, guaranteeing that the source no longer exists after the patch. `CopyOperation` deep‑copies the source value, leaving the original unchanged. |
| **Conflict detection** | The library deliberately raises `JsonPatchConflict` for any situation where the patch cannot be applied without violating the source document’s structure (e.g., inserting beyond array bounds, removing a non‑existent key). Users should catch this exception to decide on fallback strategies. |
| **Diff optimisation flag (currently unused)** | `JsonPatch.from_diff` accepts an `optimization=True` argument, but the current implementation always runs the optimization logic (replace detection, move detection). Future versions may allow disabling it. |
| **Thread‑safety** | `JsonPatch` instances are immutable after creation (they only store the original operation list). The `apply` method copies the target document unless `in_place=True`. Therefore, a single `JsonPatch` can safely be reused across threads as long as the caller respects the `in_place` semantics. |
| **Python version compatibility** | The module contains shims for Python 2/3 (`basestring`, `MutableMapping` imports). In modern environments (Python 3.8+), these branches are effectively dead code but retained for backward compatibility. |
| **Extending operations** | Adding a new JSON‑Patch operation would involve: <br>1. Subclassing `PatchOperation` and implementing `apply`. <br>2. Adding the name → class mapping in `JsonPatch.operations`. <br>3. Updating any diff logic if the new operation should be generated automatically. |
| **Performance considerations** | The diff algorithm walks the entire document tree and may hold temporary index structures for move detection, which can be memory‑intensive for large JSON payloads. For very large documents, consider disabling move detection (by altering `DiffBuilder` logic) or using a streaming diff tool. |

--- 

*End of documentation for `jsonpatch.py`.*