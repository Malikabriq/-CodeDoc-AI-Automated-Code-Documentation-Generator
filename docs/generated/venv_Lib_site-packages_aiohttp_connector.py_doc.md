# aiohttp.connector – Connection Management Layer  

*File:* `venv\Lib\site-packages\aiohttp\connector.py`  

---  

## 1. Module Purpose  

| What | Why |
|------|------|
| **Implement connector abstractions** that create, pool, reuse, and close network transports (TCP, Unix sockets, Windows named pipes). | The high‑level `aiohttp.ClientSession` needs an object that knows how to turn a `ClientRequest` into a live transport, enforce limits, keep‑alive, DNS caching, and TLS handling. |
| **Provide a public API** (`BaseConnector`, `TCPConnector`, `UnixConnector`, `NamedPipeConnector`) that can be passed to `ClientSession` or used directly. | Different environments (plain HTTP, HTTPS via proxy, Unix domain sockets, Windows named pipes) require different low‑level connection handling while sharing the same pooling / cleanup logic. |
| **Handle edge‑cases** such as TLS‑in‑TLS (HTTPS‑over‑HTTPS‑proxy), “happy‑eyeballs” address selection, DNS throttling, and cleanup of broken SSL transports. | These features are essential for a robust, production‑ready HTTP client that works on all supported Python versions and platforms. |

---  

## 2. Key Components  

### 2.1 Helper Types & Constants  

| Name | Description |
|------|-------------|
| `EMPTY_SCHEMA_SET`, `HTTP_SCHEMA_SET`, `WS_SCHEMA_SET`, `HIGH_LEVEL_SCHEMA_SET` | Frozen sets of URI schemes accepted by the various connectors. |
| `NEEDS_CLEANUP_CLOSED` | Version guard – older Python versions need an extra “cleanup‑closed‑transports” task. |
| `AddrInfoType`, `SocketFactoryType` (imported from **aiohappyeyeballs**) | Types used by the happy‑eyeballs address‑selection logic. |
| `Buffer` | Compatibility alias for a bytes‑like buffer. |
| `_DeprecationWaiter` | Small wrapper that warns if `Connector.close()` is *not* awaited. It returns a coroutine‑like object that can be awaited safely. |
| `_wait_for_close` | Internal coroutine that gathers all connection‑close futures and logs any errors. |

### 2.2 `Connection`  

*Purpose* – Public wrapper returned from `BaseConnector.connect()`.  

*Key attributes*  
- `_key` – a `ConnectionKey` identifying host / proxy / scheme.  
- `_connector` – owning connector instance.  
- `_protocol` – the `ResponseHandler` handling the HTTP protocol state machine.  

*Public API*  

| Method / Property | Behaviour |
|-------------------|-----------|
| `transport` | Returns the underlying `asyncio.Transport` (or `None` if not yet created). |
| `protocol` | Returns the `ResponseHandler` instance (or `None` after close). |
| `add_callback(cb)` | Registers a callable that will be executed when the connection is released or closed. |
| `release()` | Returns the connection to the pool (unless `force_close` or `should_close`). |
| `close()` | Forces the underlying transport to close and removes the connection from the pool. |
| `closed` (property) | `True` when the protocol has been cleared or the transport is no longer connected. |
| `__bool__` | Always `True`; useful for `if conn:` checks without accidental falsy values. |

*Internal logic* – When a `Connection` object is garbage‑collected without an explicit `release()`/`close()`, `__del__` emits a `ResourceWarning`, logs a message, and invokes the connector’s `_release` to avoid leaks.

### 2.3 `_ConnectTunnelConnection`  

A subclass of `Connection` used **only** for the CONNECT tunnel step when talking to an HTTPS proxy.  

*Overrides*  

| Method | Effect |
|--------|--------|
| `release()` | **No‑op** – the tunnel connection must never be returned to the pool, otherwise the session would wait forever for its `closed` future. |

### 2.4 `_TransportPlaceholder`  

A tiny class used while a connection is being created. It mimics the protocol interface enough for the connector’s bookkeeping (`self._acquired.add(placeholder)`). Its methods (`close`, `abort`) are no‑ops.

### 2.5 `BaseConnector`  

Abstract base class that implements **all generic pooling, cleanup, and limit handling**.  

#### Constructor  

```python
BaseConnector(
    *,
    keepalive_timeout: Union[object, None, float] = sentinel,
    force_close: bool = False,
    limit: int = 100,
    limit_per_host: int = 0,
    enable_cleanup_closed: bool = False,
    loop: Optional[asyncio.AbstractEventLoop] = None,
    timeout_ceil_threshold: float = 5,
)
```

| Parameter | Meaning |
|-----------|---------|
| `keepalive_timeout` | Seconds after which an idle connection is evicted from the pool. `None` disables the timeout; default (sentinel) → `15.0`. |
| `force_close` | If `True`, every request forces the transport to be closed after the response. |
| `limit` | Global maximum number of simultaneously *acquired* connections. `0` means unlimited. |
| `limit_per_host` | Maximum number of simultaneous connections to the same `(host, port, is_ssl)` triple. |
| `enable_cleanup_closed` | When `True` (and Python version < 3.12.7 / 3.13.1), a periodic task aborts transports that have been closed by the remote side but still linger. |
| `loop` | Optional explicit event loop; otherwise the current running loop is used. |
| `timeout_ceil_threshold` | Threshold for the “ceil‑timeout” optimisation (used by `ceil_timeout` helper). |

#### Core private data structures  

| Name | Type | Purpose |
|------|------|---------|
| `_conns` | `DefaultDict[ConnectionKey, Deque[Tuple[ResponseHandler, float]]]` | Pool of **idle** connections; the timestamp denotes the last use time. |
| `_acquired` | `Set[ResponseHandler]` | Set of **active** (in‑use) protocol instances. |
| `_acquired_per_host` | `DefaultDict[ConnectionKey, Set[ResponseHandler]]` | Same as `_acquired` but grouped per host for `limit_per_host`. |
| `_waiters` | `DefaultDict[ConnectionKey, OrderedDict[Future[None], None]]` | FIFO queue of coroutines waiting for a slot when limits are reached. |
| `_cleanup_handle` / `_cleanup_closed_handle` | `TimerHandle` | Periodic callbacks that evict stale keep‑alive connections and abort closed SSL transports. |
| `_placeholder_future` | `Future[Optional[Exception]]` | Pre‑resolved future used by `_TransportPlaceholder`. |

#### Public API  

| Method / Property | Description |
|-------------------|-------------|
| `close(*, abort_ssl=False) -> Awaitable[None]` | Public coroutine to close **all** transports. Returns a `_DeprecationWaiter` that will raise a deprecation warning if not awaited. |
| `closed` (property) | Boolean flag indicating that `close()` has been called. |
| `force_close`, `limit`, `limit_per_host` (properties) | Simple getters for the corresponding constructor arguments. |
| `connect(req, traces, timeout) -> Connection` | Main entry point used by `ClientSession`. Returns a live `Connection` (either pooled or freshly created). |
| `_available_connections(key)` | Internal helper that computes how many slots are still free for a given host, respecting both global and per‑host limits. |
| `_get(key, traces)` | Pops an idle connection from the pool, marks it as acquired, and returns a `Connection` wrapper (or `None`). |
| `_release(key, protocol, *, should_close=False)` | Returns a protocol to the pool or closes it, depending on `force_close`, `should_close`, or the protocol’s own `should_close` flag. |
| `_cleanup()` | Runs periodically to drop connections that exceeded `keepalive_timeout`. |
| `_cleanup_closed()` | Periodic abort of transports that were closed by the remote side (only needed on older Python). |
| `__aenter__ / __aexit__` | Async context manager support – `await connector.close()` on exit. |
| `__enter__ / __exit__` | Synchronous context manager (deprecated). |

#### Internal workflow  

1. **Acquire slot** – `connect()` checks `_available_connections`. If none, it creates a *waiter* future and suspends until a slot frees (via `_release_waiter`).  
2. **Reuse** – `_get()` tries to pop a keep‑alive connection that is still within the timeout. If successful, the connection is returned immediately.  
3. **Create** – If no reusable connection exists, a placeholder is inserted into the acquired set, then `_create_connection` (implemented by subclasses) is called. On success the placeholder is swapped for the real protocol.  
4. **Release** – When the user calls `Connection.release()` or `Connection.close()`, the connector decides whether to put the protocol back into `_conns` (keep‑alive) or close it (force‑close, TLS error, etc.).  

### 2.6 `_DNSCacheTable`  

Small utility that caches DNS results (list of `ResolveResult` dictionaries) per `(host, port)`.  

*Features*  

- Optional TTL (`None` → infinite).  
- `next_addrs()` returns a **round‑robin** slice of cached addresses, ensuring load‑balancing across multiple A/AAAA records.  
- `expired(key)` tells whether the cached entry exceeded the TTL.  

### 2.7 SSL helper functions  

| Function | Behaviour |
|----------|-----------|
| `_make_ssl_context(verified: bool) -> SSLContext` | Returns a **verified** or **unverified** `ssl.SSLContext`. If `ssl` module is unavailable, returns `None`. |
| `_SSL_CONTEXT_VERIFIED`, `_SSL_CONTEXT_UNVERIFIED` | Module‑level pre‑created contexts (blocking I/O already performed at import). |

### 2.8 `TCPConnector`  

Concrete implementation for **TCP / TLS** connections (the default for HTTP/HTTPS).  

#### Constructor  

```python
TCPConnector(
    *,
    verify_ssl: bool = True,
    fingerprint: Optional[bytes] = None,
    use_dns_cache: bool = True,
    ttl_dns_cache: Optional[int] = 10,
    family: socket.AddressFamily = socket.AF_UNSPEC,
    ssl_context: Optional[SSLContext] = None,
    ssl: Union[bool, Fingerprint, SSLContext] = True,
    local_addr: Optional[Tuple[str, int]] = None,
    resolver: Optional[AbstractResolver] = None,
    keepalive_timeout: Union[None, float, object] = sentinel,
    force_close: bool = False,
    limit: int = 100,
    limit_per_host: int = 0,
    enable_cleanup_closed: bool = False,
    loop: Optional[asyncio.AbstractEventLoop] = None,
    timeout_ceil_threshold: float = 5,
    happy_eyeballs_delay: Optional[float] = 0.25,
    interleave: Optional[int] = None,
    socket_factory: Optional[SocketFactoryType] = None,
    ssl_shutdown_timeout: Union[_SENTINEL, None, float] = sentinel,
)
```

| Param | Meaning |
|-------|---------|
| `verify_ssl` | Whether to verify server certificates (default `True`). |
| `fingerprint` | Expected SHA‑256 fingerprint for certificate pinning. |
| `use_dns_cache` | Enable the in‑memory DNS cache (`_DNSCacheTable`). |
| `ttl_dns_cache` | Seconds after which a cached DNS entry expires (default `10`). |
| `family` | Preferred address family (`AF_INET`, `AF_INET6`, or `AF_UNSPEC`). |
| `ssl_context` | Explicit `SSLContext` (overrides `verify_ssl`). |
| `ssl` | Shortcut to configure SSL verification/fingerprint/context (mirrors `ClientSession` argument). |
| `local_addr` | `(host, port)` tuple to bind the client socket. |
| `resolver` | Custom `AbstractResolver` implementation; defaults to `DefaultResolver`. |
| `happy_eyeballs_delay` | Delay between address‑family attempts per RFC 8305. `None` disables the algorithm. |
| `interleave` | “First address‑family count” for happy‑eyeballs. |
| `socket_factory` | Callable that builds sockets from `AddrInfoType`. |
| `ssl_shutdown_timeout` | **Deprecated** – graceful SSL shutdown timeout (removed in aiohttp 4.0). |

#### Important methods  

| Method | Description |
|--------|-------------|
| `_close()` | Cancels any pending DNS resolution futures, then delegates to `BaseConnector._close`. |
| `close(*, abort_ssl=False)` | If the connector owns its resolver, it first closes the resolver, then forwards to `BaseConnector.close`. Handles deprecation of `ssl_shutdown_timeout`. |
| `_resolve_host(host, port, traces)` | Asynchronously resolves DNS, using the cache if enabled. Implements **throttling**: multiple concurrent lookups for the same host share a single underlying resolver task. |
| `_resolve_host_with_throttle(...)` | The actual task that performs the DNS lookup, fills the cache, and notifies all waiters. |
| `_create_connection(req, traces, timeout)` | Delegates to `_create_proxy_connection` or `_create_direct_connection` depending on `req.proxy`. |
| `_create_direct_connection` | Resolves the host (honoring DNS cache / happy‑eyeballs), iterates over the resulting address list, attempts to `create_connection` for each, honouring fingerprints and handling retries. |
| `_create_proxy_connection` | Handles CONNECT‑tunnel establishment for HTTPS over HTTP/HTTPS proxies, including TLS‑in‑TLS handling, proxy authentication, and fallback to plain `start_tls`. |
| `_wrap_create_connection` / `_wrap_existing_connection` | Low‑level helpers that call `loop.create_connection` (or `loop.create_unix_connection`) inside a `ceil_timeout` context and translate OS‑level errors into aiohttp‑specific exceptions (`ClientConnectorError`, `ClientConnectorCertificateError`, …). |
| `_start_tls_connection` | Calls `loop.start_tls` (or emulated logic) to wrap a raw TCP transport in TLS for CONNECT tunnels. Handles fingerprint verification after the handshake. |
| `_get_ssl_context(req)` | Determines the correct `SSLContext` for a request (handles per‑request `ssl=` overrides, fingerprint‑only mode, default verified/ unverified contexts). |
| `_get_fingerprint(req)` | Returns a `Fingerprint` object if the request or connector was configured with one. |
| `_convert_hosts_to_addr_infos(hosts)` | Transforms the `ResolveResult` dictionaries obtained from a resolver into the `addr_infos` format expected by `aiohappyeyeballs.start_connection`. |
| `_warn_about_tls_in_tls` | Emits a `RuntimeWarning` when TLS‑in‑TLS is attempted on a runtime that does not support it (e.g., asyncio < 3.11). |
| `_check_loop_for_start_tls` / `_loop_supports_start_tls` | Detect whether the current event‑loop implementation provides `loop.start_tls`. Used for proxy‑HTTPS handling. |

#### Public fields  

- `family`, `use_dns_cache` – read‑only properties exposing the constructor values.  

#### Interaction with other components  

- **Resolver**: either a user‑provided `AbstractResolver` or the default `DefaultResolver`. The connector manages its lifecycle (`close`).  
- **aiohappyeyeballs**: used for parallel address‑family connection attempts, interleaving, and for the “happy‑eyeballs delay”.  
- **ClientRequest**, **ResponseHandler**, **ClientTimeout**: part of the public client API; the connector receives a request object, creates a protocol (`ResponseHandler`) and respects the request‑level timeout values.  

### 2.9 `UnixConnector`  

Connector for **Unix domain sockets** (POSIX only).  

| Constructor arguments | Same semantics as `BaseConnector` plus: |
|-----------------------|------------------------------------------|
| `path: str` | Filesystem path of the Unix socket. |

*Key method*  

```python
async def _create_connection(self, req, traces, timeout) -> ResponseHandler
```

Calls `loop.create_unix_connection(self._factory, self._path)` inside a `ceil_timeout` guard and translates `OSError` into `UnixClientConnectorError`.  

### 2.10 `NamedPipeConnector`  

Connector for **Windows named pipes** (requires a `ProactorEventLoop`).  

| Constructor args | Same as `BaseConnector` plus: |
|------------------|--------------------------------|
| `path: str` | Windows named‑pipe path (e.g. `r'\\.\pipe\my_pipe'`). |

*Implementation notes*  

- Validates that the current loop is a `ProactorEventLoop`; otherwise raises `RuntimeError`.  
- Uses `loop.create_pipe_connection` (proactor‑specific) to obtain a transport & protocol.  
- Performs a tiny `await asyncio.sleep(0)` after connection to ensure the protocol’s `connection_made` callback has been executed (required for later `assert conn.transport is not None`).  

---  

## 3. Dependencies & Relationships  

### 3.1 Imports (grouped by purpose)  

| Module | Used For |
|--------|----------|
| `asyncio`, `socket`, `sys`, `warnings`, `traceback` | Core event‑loop, networking primitives, version checks, deprecation handling. |
| `collections` (`OrderedDict`, `defaultdict`, `deque`) | Pool / wait‑queue data structures. |
| `contextlib.suppress` | Silently ignore errors in callbacks / cleanup. |
| `http.HTTPStatus` | Human‑readable status names for proxy errors. |
| `itertools` (`chain`, `cycle`, `islice`) | DNS cache round‑robin, address‑info manipulation. |
| `time.monotonic` | Precise timeout / keep‑alive timestamps. |
| `types.TracebackType` | Type hint for `__del__` signature. |
| `typing` (extensive) | Static type hints for all public APIs. |
| `aiohappyeyeballs` (and its types) | Implements the “happy‑eyeballs” algorithm for IPv4/IPv6 fallback and address interleaving. |
| `aiohttp` sub‑modules (`hdrs`, `helpers`, `client_exceptions`, `client_proto`, `client_reqrep`, `log`, `resolver`) |  |
| `ssl` (optional) | TLS context creation, certificate/SSL error handling. |

### 3.2 Interaction Graph  

```
ClientSession
   └─> TCPConnector / UnixConnector / NamedPipeConnector (via `connector=`)
          ├─ uses BaseConnector for pooling / limits
          ├─ uses aiohappyeyeballs for address selection
          ├─ uses resolver (DefaultResolver or custom) for DNS
          ├─ creates ResponseHandler (protocol) for each connection
          └─ interacts with ClientRequest (holds URL, proxy, ssl, etc.)
```

*Who depends on this file?*  

- `aiohttp.client` (the high‑level client implementation) imports `TCPConnector` as the default connector.  
- Users of the library can import `TCPConnector` directly to customize DNS, SSL, limits, etc.  

*What does this file depend on?*  

- Low‑level networking primitives (`asyncio`, `socket`).  
- TLS handling (`ssl`).  
- Helper utilities (`helpers.weakref_handle`, `ceil_timeout`).  
- Error hierarchy (`client_exceptions`).  
- Resolver interface (`abc.AbstractResolver`).  

---  

## 4. Workflow Description  

Below is a **high‑level call flow** for a normal HTTPS request via the default `TCPConnector`.

1. **User code** creates a `ClientSession(connector=TCPConnector(...))`.  
2. `Session._request()` builds a `ClientRequest` and calls `connector.connect(request, traces, timeout)`.  

### 4.1 Inside `BaseConnector.connect`  

| Step | Action |
|------|--------|
| **a.** | Compute `key = request.connection_key`. |
| **b.** | Try to obtain a pooled connection: `await self._get(key, traces)`. If success → return `Connection`. |
| **c.** | If no pool entry, enter `ceil_timeout` on `timeout.connect`. |
| **d.** | Verify limits with `_available_connections`. If none, call `_wait_for_available_connection` (which creates a future, puts it into `_waiters[key]`, and suspends). |
| **e.** | Insert a `_TransportPlaceholder` into `_acquired` to reserve a slot while the real connection is being built. |
| **f.** | Call subclass `_create_connection(request, traces, timeout)`. For `TCPConnector` this means either a direct socket or a proxy tunnel. |
| **g.** | On success, replace placeholder with the real `ResponseHandler` in `_acquired`. |
| **h.** | Return a `Connection` wrapper holding the protocol and a reference to the connector. |

### 4.2 Direct connection (`TCPConnector._create_direct_connection`)  

1. Resolve hostname using `_resolve_host` (cache‑aware, throttled).  
2. Convert each DNS result into `addr_infos`.  
3. Iterate over `addr_infos` (happy‑eyeballs may reorder them). For each:  
   - Call `_wrap_create_connection` → `aiohappyeyeballs.start_connection` → `loop.create_connection`.  
   - If TLS is required, pass the selected `SSLContext` and `server_hostname`.  
   - On failure (network error / timeout) store the exception, pop the address from the list, and continue.  
4. After a successful transport is obtained, optionally verify a fingerprint.  
5. Return the `(transport, protocol)` pair.

### 4.3 Proxy‑tunnel connection (`TCPConnector._create_proxy_connection`)  

1. Build a minimal `ClientRequest` for the **CONNECT** method towards the proxy.  
2. Open a **plain TCP** connection to the proxy (`_create_direct_connection`).  
3. Send the CONNECT request, receive the response.  
4. If the proxy returns `200`, two paths:  

   - **Runtime supports `start_tls`** → call `_start_tls_connection` to wrap the raw transport in TLS (TLS‑in‑TLS).  
   - **Runtime does *not* support `start_tls`** → duplicate the raw socket, close the proxy transport, and manually create a new TLS connection with `_wrap_existing_connection`.  

5. Return the TLS‑wrapped transport & protocol.  

### 4.4 Cleanup  

- **Keep‑alive eviction** runs every `keepalive_timeout` seconds via `_cleanup_handle`. It removes stale connections from the pool and aborts any SSL transports that were closed remotely (if `enable_cleanup_closed`).  
- **Close** (`connector.close()`) cancels all pending DNS lookups, stops cleanup timers, closes every transport in the pool and every *acquired* protocol, and optionally aborts SSL immediately (`abort_ssl=True`).  

---  

## 5. Usage Examples  

> **Note:** Only the public API is demonstrated; internal helpers are not meant for direct use.

### 5.1 Simple HTTP client with custom limits  

```python
import asyncio
from aiohttp import ClientSession, TCPConnector

async def main():
    connector = TCPConnector(limit=200, limit_per_host=10, keepalive_timeout=30)
    async with ClientSession(connector=connector) as session:
        async with session.get('https://example.com') as resp:
            print(resp.status)
            text = await resp.text()
            print(text[:200])

    # Explicit close (optional – context manager already does it)
    await connector.close()

asyncio.run(main())
```

### 5.2 Using DNS cache with a custom TTL  

```python
connector = TCPConnector(use_dns_cache=True, ttl_dns_cache=60)   # 1‑minute cache
session = ClientSession(connector=connector)

# Later you can clear the cache selectively:
connector.clear_dns_cache(host='example.com', port=443)   # remove one entry
connector.clear_dns_cache()                             # clear all
```

### 5.3 HTTPS via an HTTPS proxy (TLS‑in‑TLS)  

```python
import aiohttp

proxy_url = 'https://proxy.example.org:8443'
connector = aiohttp.TCPConnector()
session = aiohttp.ClientSession(connector=connector, proxy=proxy_url)

async with session.get('https://secure-site.com') as r:
    print(r.status)
```

The connector will automatically create a CONNECT tunnel, start TLS over the tunnel, and emit warnings if the runtime does not support TLS‑in‑TLS.

### 5.4 Unix domain socket  

```python
connector = aiohttp.UnixConnector(path='/tmp/aiohttp.sock')
session = aiohttp.ClientSession(connector=connector)

async with session.get('http://localhost/') as resp:
    print(await resp.text())
```

### 5.5 Named pipe (Windows)  

```python
connector = aiohttp.NamedPipeConnector(path=r'\\.\pipe\my_pipe')
session = aiohttp.ClientSession(connector=connector)
# Use it as a normal HTTP client...
```

---  

## 6. Notes for Developers  

| Area | Important considerations |
|------|--------------------------|
| **Connection Pooling** | The pool stores **protocol** objects, not raw transports. When a connection is released, the protocol is kept alive and the underlying transport is kept open until keep‑alive timeout fires. |
| **Thread‑safety** | All public methods assume they are called from the **same event loop** that created the connector. No explicit locks are used; mixing loops will cause race conditions. |
| **Happy‑eyeballs** | `TCPConnector` delegates address‑selection to `aiohappyeyeballs.start_connection`. The `happy_eyeballs_delay` and `interleave` arguments allow fine‑tuning; setting the delay to `None` disables the algorithm (fallback to first address only). |
| **DNS throttling** | When many coroutines resolve the same host simultaneously, only **one** DNS query is performed. All other callers wait on a shared future stored in `_throttle_dns_futures`. Errors are propagated to all waiters. |
| **TLS‑in‑TLS** | Only supported on Python 3.11+ (or uvloop). The code checks `loop.start_tls`. If missing, a warning is emitted and the connector falls back to a duplicated‑socket approach (which is less efficient). |
| **SSL shutdown** | The `ssl_shutdown_timeout` parameter is deprecated. On Python 3.11+ it is passed to `loop.start_tls` if non‑zero; on older versions it is ignored and a `RuntimeWarning` is emitted. |
| **Resource warnings** | Unreleased `Connection` or an unclosed `BaseConnector` emit `ResourceWarning`. The `__del__` implementations also log to the event‑loop’s exception handler. |
| **Compatibility layer** | The module contains several version guards (`NEEDS_CLEANUP_CLOSED`, `sys.version_info >= (3,12)`) to leverage newer `asyncio.Task` optimisations (`eager_start`). |
| **Error mapping** | All low‑level `OSError`, `ssl.SSLError`, etc., are translated to aiohttp‑specific exceptions (`ClientConnectorError`, `ClientConnectorSSLError`, `ClientConnectorCertificateError`). This centralises error handling for the rest of the client. |
| **Extensibility** | Custom connectors can inherit from `BaseConnector` and implement `_create_connection`. The pool/limit/cleanup logic will work unchanged. |
| **Testing** | Because the connector heavily relies on the event loop, tests should use `asyncio.run` or the `pytest-asyncio` fixture to guarantee a running loop. Mocking of `aiohappyeyeballs.start_connection` and the resolver is useful for unit tests. |

---  

*End of documentation.*